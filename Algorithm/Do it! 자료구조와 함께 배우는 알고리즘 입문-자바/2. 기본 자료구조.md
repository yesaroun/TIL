#알고리즘 #java #자료구조 

# 배열 요소의 최댓값 구하기(p56)
## 배열 요소의 최댓값 구하기

```java
// 배열의 a의 요소가 3개일 때 세 요소 a[0], a[1], a[2] 중 최댓값을 구하는 코드
max = a[0];
if (a[1] > max)
		max = a[1];
if (a[2] > max)
		max = a[2];
```

요솟수가 n이면 if문 실행은 n-1번 필요하다. 그러므로 a[0], a[1], …, a[n-1]의 최댓값을 구하는 프로그램은 다음과 같다.
```java
max = a[0];
for (int i = 1; i < n; i++)
		if (a[i] > max)
				max = a[i];
```

이처럼 배열 요소를 하나씩 차례로 조사하는 과정을 알고리즘 용어로 주사(traverse) 또는 스캔이라고 한다.


# 접근 제한자(p61)
## 접근 제한자의 종류

1.  public : 모든 접근 허용
2.  protected : 같은 패키지(폴더)의 객체, 상속 관계의 객체 허용
3.  default : 같은 패키지(폴더)의 객체 허용
4.  private : 현재의 객체 안에서만 허용

## 접근 제한자 사용

1.  클래스 : public, default
2.  생성자 : public, protected, default, private
3.  멤버 변수 : public, protected, default, private
4.  멤버 메서드 : public, protected, default, private
5.  지역 변수: 접근 제한자를 사용할 수 없음


# 난수의 생성(p63)
Random 클래스의 인스턴스는 일련의 의사 난수(진짜 난수와 비슷한 가짜 난수)를 생성한다.

난수는 무에서 생성되는 것이 아니라 ‘seed’라는 수의 값을 바탕으로 여러 연산을 수행하여 얻는다.

Random 클래스에서는 48비트의 seed를 사용하고, 이 seed는 선형 합동법이라는 계산법에 의해 특정 수(난수)로 바뀐다.

### Random 클래스의 인스턴스 생성
```java
# seed를 임의로 생성
Random rand = new Random();
# seed를 지정
Random rand = new Random(n);
```


|구하는 식(메서드 호출)|자료형|생성한 값의 범위|
|--------------------|------|---------------|
|nextBoolean()|boolean|true or false|
|nextInt()|int|-2147483648 ~ +2147483647|
|nextInt(n)|int|0 ~ n - 1|
|nextLong()|long|-9223372036854775808 ~ +9223372036854775807|
|nextDouble()|double|0.0 이상 1.0 미만|
|nextFloat()|float|0.0 이상 1.0 미만|

java.lang.Math 클래스에서도 사양은 조금 다르지만 난수를 생성하는 라이브러리를 제공한다.


## cf) 의사 난수와 선형 합동법
---
## 의사 난수

의사 : 실제와 비슷하다

컴퓨터 과학에서는 보통 특정 입력값이나 컴퓨터 환경에 따라 무작위로 선택한 것처럼 보이는 난수를 생성하는데, 그 입력값이나 컴퓨터 환경이 같다면 그 결괏값은 항상 같다. 결국 컴퓨터에서 생성된 모든 난수는 미리 컴퓨터가 계산해 둔 ‘의사 난수’이다.

의사 난수는 난수처럼 보이지만 일정한 규칙에 따라 생성한다. 여기서 난수라고 부르는 건 다음에 생성할 난수를 예측할 수 있기 때문이다. 의사 난수가 아닌 진짜 난수로는 생성할 난수를 예측할 수 없다.

컴퓨터는 계산된 결고만 가지고 난수를 생성하는데, 이 계산된 결과는 입력값에 의해 결정되므로 이 값으로 임의의 난수를 생성할 수는 없다.(컴퓨터를 처음 켜면 난수표를 생성하여 보관한다고 생각하면 된다.) 프로그램에서 매번 같은 방법으로 이 값을 가져오면 처음 실행할 때 이외에는 난수라고 할 수 없다. 그래서 보통 seed(씨앗 값)이라고 부르는 수를 매개변수로 매번 다르게 전달하여 다른 의사 난수를 생성해야 한다. 보통 seed값은 시간에 따라 다르게 생성된다. 시간은 매 순간 바뀌므로 이전에 발생한 의사 난수를 다시 생성하진 않는다.

## 선형 합동법

 선형 합동법(linear congruential method): 보편적으로 사용하는 의사 난수 생성기 현재 의사 난수값을 A배 하고 C를 더한 다음, M으로 나눈 나머지를 의사 난수로 선택하는 방법이다. 계산 공식이 간단하여 연산이 빠르고 메모리를 적게 사용하지만, 수를 바꾸는(modulate)연산을 할 때는 변수의 최댓값을 주기로 가지므로 자료형 이상의 주기를 사용할 수 없다. 선형 합동법은 간단한 공식과 주기의 제한으로 ‘예측 불가능성’이 없다. 따라서 선형 합동법을 암호 기술에는 사용할 수 없다. C의 rand 함수, 자바의 java.util.Random 클래스는 모두 선형 합동법을 사용한다.
 
---



# 배열 요소를 역순으로 정렬하기(p64)
```java
// 배열 요소에 값을 읽어 들여 역순으로 정렬

package chap02;

import java.util.Arrays;
import java.util.Scanner;

public class ReverseArray {

    // 배열 요소 a[idx1]과 a[idx2]의 값을 바꿈
    static void swap(int[] a, int idx1, int idx2) {
        int t = a[idx1];
        a[idx1] = a[idx2];
        a[idx2] = t;
    }

    // 배열 a의 요소를 역순으로 정렬
    static void reverse(int[] a) {
        for (int i = 0; i < a.length / 2; i++) {
            swap(a, i, a.length - i - 1);
        }
    }

    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        System.out.print("요솟수: ");
        int num = stdIn.nextInt();

        int[] x = new int[num];

        for (int i = 0; i < num; i++) {
            System.out.print("x[" + i + "]: ");
            x[i] = stdIn.nextInt();
        }

        // 배열 a의 요소를 역순으로 정렬
        reverse(x);

        System.out.println("요소를 역순으로 정렬했습니다.");
        System.out.println("x = " + Arrays.toString(x));
    }
}
//--==>>
/*
요솟수: 3
x[0]: 5
x[1]: 3
x[2]: 1
요소를 역순으로 정렬했습니다.
x = [1, 3, 5]
 */
```



