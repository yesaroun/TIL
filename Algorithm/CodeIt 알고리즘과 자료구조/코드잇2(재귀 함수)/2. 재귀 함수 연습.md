# 2. 재귀 함수 연습


# 1. 파보나치 수열

피보나치 수열이란 첫 번째 항과 두 번째 항이 1이고, 세 번째 항부터는 바로 앞의 두 항의 합으로 정의된 수열입니다.
예를 들어서 세 번째 항은 첫 번째 항(1)과 두 번째 항(1)을 더한 2이며, 네 번째 항은 두 번째 항(1)과 세 번째 항(2)을 더한 3이 될 것입니다.
이러한 방식으로 피보나치 수열의 첫 10개 항은 1, 1, 2, 3, 5, 8, 13, 21, 34, 55입니다.
파라미터로 1 이상의 자연수 **`n`**을 받고, n번째 피보나치 수를 리턴하는 재귀 함수 **`fib`**를 쓰세요. 반복문은 쓰면 안됩니다!

```python
# n번째 피보나치 수를 리턴
def fib(n):
    # 코드를 입력하세요.

# 테스트: fib(1)부터 fib(10)까지 출력
for i in range(1, 11):
    print(fib(i))
```

```
1
1
2
3
5
8
13
21
34
55
```

### **힌트 1**

재귀 함수에는 recursive case와 base case가 있습니다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

우선 base case가 무엇인지 생각해 볼까요?

### **힌트 2**

인풋이 **`n`**이면, 함수 **`fib`**는 피보나치 수열의 n번째 항을 구해야 합니다.
인풋 **`n`**의 값이 무엇일 때 base case일까요?

### **힌트 3**

현재 문제가 너무 커서 바로 풀지 못하는 경우가 recursive case입니다. **`fib(10)`**의 리턴값이 무엇인지 머릿속으로 바로 생각해내지 못하죠? 그런 경우에 recursive case가 필요한 거죠.
반대로 현재 문제가 충분히 작아서 바로 풀 수 있는 경우가 base case입니다.
인풋 **`n`**이 어떤 숫자일 때 답을 바로 생각해 낼 수 있나요?

### **힌트 4**

인풋 **`n`**이 **`1`**이거나 **`2`**인 경우에는 답을 바로 생각해낼 수 있습니다.
피보나치 수열의 정의 자체가 첫 번째 항과 두 번째 항이 1이고 세 번째 항부터는 앞선 두 항의 합인 수열입니다. 그렇기 때문에 **`n`**이 **`1`**이거나 **`2`**면 고민할 것도 없이 리턴값은 **`1`**이 되겠죠.
정리하자면, **`n`**이 **`1`**이거나 **`2`**이면 더 이상 부분 문제를 만들지 않고 바로 **`1`**을 리턴하면 됩니다.
이 부분을 코드로 쓰면 어떻게 될까요?

### **힌트 5**

함수에 들어오는 인풋이 **`1`**이거나 **`2`**이면, 즉 **`3`**보다 작을 때, **`1`**을 리턴해 주면 되겠죠?

```python
def fib(n):
    # base case
    if n < 3:
        return 1

```

### **힌트 6**

Base case를 알아냈으니, 이제 recursive case가 무엇일지 한 번 생각해 볼까요?
**`n`**이 **`1`**이나 **`2`**인 경우에는 바로 답을 알고 리턴했지만, **`n`**이 **`2`**보다 큰 경우에는 바로 답을 구하지 못하기 때문에 부분 문제를 풀어야 합니다.
예를 들어 **`n`**이 **`5`**인 경우를 생각해 보죠. 현재 문제는 피보나치 수열의 5번째 항을 구하는 것입니다. 우리가 풀어야 할 부분 문제는 무엇일까요?

### **힌트 7**

5번째 항은 4번째 항과 3번째 항의 합인데요. 따라서 5번째 항을 구하기 위해서는 결국 피보나치 수열의 4번째 항과 3번째 항을 구해야 한다는 거죠.

### **힌트 8**

피보나치 수열의 4번째 항과 3번째 항은 **`fib(4)`**와 **`fib(3)`**입니다. 바로 우리가 찾던 “같은 형태의 더 작은 부분 문제"인 거죠.
**`n`**이 **`5`**면, **`fib(4)`** 와 **`fib(3)`**을 더해주면 되는데, 이것을 일반화하면 **`fib(n - 1)`**과 **`fib(n - 2)`**를 더하는 것입니다.
이제 이걸 코드로 옮겨보세요.

## **해답**

```python
def fib(n):
    # base case
    if n < 3:
        return 1

    # recursive case
    return fib(n - 1) + fib(n - 2)

# 테스트: fib(1)부터 fib(10)까지 출력
for i in range(1, 11):
    print(fib(i))

```

# 2. 숫자 합

*n*번째 삼각수(triangle number)는 자연수 1부터 n까지의 합입니다. 파라미터로 정수값 **`n`**을 받고 n번째 삼각수를 리턴해주는 재귀 함수 **`triangle_number`**를 쓰세요. n은 1 이상의 자연수라고 가정합시다.
함수 안에 반복문은 쓰면 안됩니다!

```python
# 1부터 n까지의 합을 리턴
def triangle_number(n):
    # 코드를 입력하세요

# 테스트: triangle_number(1)부터 triangle_number(10)까지 출력
for i in range(1, 11):
    print(triangle_number(i))
```

```
1
3
6
10
15
21
28
36
45
55
```

### **힌트 1**

재귀 함수에는 recursive case와 base case가 있습니다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

우선 base case가 무엇인지 생각해 볼까요?

### **힌트 2**

인풋이 **`n`**이면, 함수 **`triangle_number`**는 *n*부터 1까지의 숫자를 더해야 합니다(1부터 n까지 더하는 것과 동일하죠).
인풋 **`n`**의 값이 무엇일 때 base case일까요?

### **힌트 3**

현재 문제가 너무 커서 바로 풀지 못하는 경우가 recursive case입니다. **`triangular_number(50)`**의 리턴값이 무엇인지 머릿속으로 바로 생각해내지 못하죠? 그런 경우에는 recursive case가 필요한 거죠.
반대로 현재 문제가 충분히 작아서 바로 풀 수 있는 경우가 base case입니다.
인풋 **`n`**이 어떤 값일 때 문제가 충분히 작아서 답을 바로 생각해낼 수 있나요?

### **힌트 4**

인풋 **`n`**이 **`1`**인 경우에 답을 바로 생각해낼 수 있습니다.
**`n`**이 **`1`**이라는 것은 자연수 1부터 1까지 더하라는 의미인데요. 고민할 것도 없이 답은 1입니다. 그러니까 **`n`**이 **`1`**이면 부분 문제를 더 이상 만들지 않고 바로 **`1`**을 리턴하면 되겠죠?
이 부분을 코드로 쓰면 어떻게 될까요?

### **힌트 5**

함수에 들어오는 인풋이 **`1`**일 때, 즉 **`n`**이 **`1`**일 때, 숫자 **`1`**을 리턴하면 되겠죠?

```python
def triangle_number(n):
    # base case
    if n == 1:
        return 1
```

### **힌트 6**

Base case를 알아냈으니, 이제 recursive case는 무엇일지 한 번 생각해 볼까요?
**`n`**이 **`1`**인 경우에는 바로 답을 알고 리턴했지만, **`n`**이 **`1`**보다 큰 경우에는 바로 답을 구하지 못하기 때문에 부분 문제를 풀어야 합니다.
예를 들어 **`n`**이 **`5`**인 경우를 생각해 보죠. 일단 문제는 5 + 4 + 3 + 2 + 1을 해결하는 것입니다. 우리가 풀어야 할 부분 문제는 무엇일까요?
우리에게 현재 주어진 정보는 **`n`**이 **`5`**라는 것입니다. 5와 4 + 3 + 2 + 1의 결과값을 더하면 되는데요. 4 + 3 + 2 + 1은 뭔가 익숙한 형태입니다.

### **힌트 7**

4 + 3 + 2 + 1은 **`triangle_number(4)`**입니다. 바로 우리가 찾던 같은 형태의 더 작은 "부분 문제"인 것이죠.
**`n`**이 **`5`**면 **`5`**와 **`triangle_number(4)`**을 더하면 되는데, 이것을 일반화하면 **`n`**과 **`triangle_number(n - 1)`**을 더하는 것입니다.
이제 이걸 코드로 옮겨보세요.

## **해답**

```python
def triangle_number(n):
    # base case
    if n == 1:
        return 1

    # recursive case
    return n + triangle_number(n - 1)

for i in range(1, 11):
    print(triangle_number(i))

```

# 3. 자릿수 합

파라미터로 정수값 **`n`**을 받고 **`n`**의 각 자릿수의 합을 리턴해주는 재귀함수 **`sum_digits`**를 쓰세요. 반복문을 쓰지 말고, 재귀(recursion)의 개념을 활용해주세요!

```python
# n의 각 자릿수의 합을 리턴
def sum_digits(n):
    # 코드를 작성하세요.

# 테스트
print(sum_digits(22541))
print(sum_digits(92130))
print(sum_digits(12634))
print(sum_digits(704))
print(sum_digits(3755))
```

```
14
15
16
11
20
```

### **힌트 1**

재귀 함수에는 recursive case와 base case가 있습니다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

우선 base case가 무엇인지 생각해 볼까요?

### **힌트 2**

인풋이 **`n`**이면, 함수 **`sum_digits`**는 **`n`**의 각 자릿수의 합을 리턴해 줘야 하죠.
인풋 **`n`**이 어떤 특징을 가질 때 base case일까요?

### **힌트 3**

현재 문제가 너무 커서 바로 풀지 못하는 경우가 recursive case입니다. **`sum_digits(13456235)`**의 리턴값이 무엇인지 머릿속으로 바로 생각해 내지 못하죠? 그런 경우에는 recursive case가 필요한 거죠.
반대로 현재 문제가 충분히 작아서 바로 풀 수 있는 경우가 base case입니다.
인풋 **`n`**이 어떤 특징을 가질 때 답을 바로 생각해 낼 수 있나요?

### **힌트 4**

인풋 **`n`**이 한 자릿수면 바로 답을 바로 생각해 낼 수 있습니다. 생각할 것도 없이 답은 **`n`** 그 자체가 되겠죠. 이 경우, 부분 문제를 더 이상 만들지 않고 바로 **`n`**을 리턴해주면 됩니다.
코드로 쓰면 어떻게 될까요?

### **힌트 5**

들어오는 인풋 **`n`**이 한 자릿수면 바로 **`n`**을 리턴해 주면 되는데요. **`n`**이 **`10`**보다 작으면 **`n`**이 한 자릿수라는 걸 확신할 수 있습니다.

```python
def sum_digits(n):
    # base case
    if n < 10:
        return n
```

### **힌트 6**

Base case를 알아냈으니, 이제 recursive case는 무엇일지 한 번 생각해 볼까요?
**`n`**이 한 자릿수일 경우에는 바로 답을 알고 리턴했지만, **`n`**이 한 자릿수보다 큰 경우에는 바로 답을 구하지 못하기 때문에 부분 문제를 풀어야 합니다.
예를 들어 **`n`**이 **`12345`**인 경우를 생각해 봅시다. 12345의 각 자릿수의 합을 구하기 위해서, 우리가 풀어야 할 부분 문제는 무엇일까요?

### **힌트 7**

12345의 자릿수 합을 구하기 위해서는, 가장 마지막 자릿수인 5에 1234의 자릿수 합을 더해주면 되는데요. 1234의 자릿수 합을 구하는 문제는 많이 익숙한 형태입니다.

### **힌트 8**

1234의 자릿수 합을 구하는 것은 **`sum_digits(1234)`**입니다. 바로 우리가 찾던 “같은 형태의 더 작은 부분 문제"인 거죠.
지금까지 이야기한 걸 일반화해서 코드로 옮겨보세요.

## **해답**

```python
def sum_digits(n):
    # base case
    if n < 10:
        return n

    # recursive case
    return n % 10 + sum_digits(n // 10)

print(sum_digits(22541))
print(sum_digits(92130))
print(sum_digits(12634))
print(sum_digits(704))
print(sum_digits(3755))
```

# 4. 리스트 뒤집기

파라미터로 리스트 **`some_list`**를 받고, 뒤집힌 리스트를 리턴해 주는 재귀 함수 **`flip`**을 쓰세요.
반복문은 쓰면 안됩니다!

```python
# 파라미터 some_list를 거꾸로 뒤집는 함수
def flip(some_list):
    # 코드를 입력하세요.

# 테스트
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
some_list = flip(some_list)
print(some_list)
```

```
[9, 8, 7, 6, 5, 4, 3, 2, 1]
```

### **힌트 1**

재귀 함수에는 recursive case와 base case가 있습니다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

우선 base case가 무엇인지 생각해 볼까요?

### **힌트 2**

인풋이 **`some_list`**이면, 함수 **`flip`**은 뒤집힌 리스트를 리턴해 줍니다.
인풋 **`some_list`**가 어떤 특징을 가질 때 base case일까요?

### **힌트 3**

현재 문제가 너무 커서 바로 풀지 못하는 경우가 recursive case입니다. **`flip([1, 6, 4, 2, 5, 7, 2, 13, 2, 8])`**의 리턴값이 무엇인지 바로 알 수는 없죠? 그런 경우에는 recursive case가 필요한 것입니다.
반대로 현재 문제가 충분히 작아서 바로 풀 수 있는 경우가 base case입니다.
인풋 **`some_list`**가 어떤 특징을 가질 때 답을 바로 생각해낼 수 있나요?

### **힌트 4**

인풋 **`some_list`**의 길이가 0이나 1인 경우에 답을 바로 생각해 낼 수 있습니다. 길이가 0이거나 1인 리스트를 뒤집으면, 고민할 것 없이 답은 **`some_list`** 자체가 되겠죠.
그런 경우 부분 문제를 더 이상 만들지 않고 바로 **`some_list`**를 리턴해 주면 됩니다.
이 부분을 코드로 쓰면 어떻게 될까요?

### **힌트 5**

인풋 **`some_list`**의 길이가 **`0`**이거나 **`1`**일 때, 그냥 **`some_list`**를 리턴해 주면 되겠죠?

```python
def flip(some_list):
    # base case
    if len(some_list) == 0 or len(some_list) == 1:
        return some_list
```

### **힌트 6**

Base case를 알아냈으니, 이제 recursive case는 무엇일지 한 번 생각해 볼까요?
**`some_list`**의 길이가 **`0`**이거나 **`1`**인 경우에는 바로 답을 알고 리턴했지만, **`some_list`**의 길이가 **`1`**보다 큰 경우에는 바로 답을 알지 못하기 때문에 부분 문제를 풀어야 합니다.
예를 들어 **`some_list`**가 **`[1, 2, 3, 4, 5]`**인 경우를 생각해 봅시다. **`[1, 2, 3, 4, 5]`**를 뒤집기 위해서 우리가 풀어야 할 부분 문제는 무엇일까요?
우선 **`[1, 2, 3, 4, 5]`**를 두 리스트 **`[1, 2, 3, 4]`**와 **`[5]`**로 분리시켜봅시다. 여기서 **`[1, 2, 3, 4]`**를 뒤집고, 그것의 결과물 앞에 **`[5]`**를 붙이면 되겠죠?
그런데 **`[1, 2, 3, 4]`**를 뒤집는 문제는 뭔가 익숙한 형태입니다.

### **힌트 7**

**`[1, 2, 3, 4]`**를 뒤집는 것은 바로 **`flip([1, 2, 3, 4])`**입니다. 바로 우리가 찾던 같은 형태의 더 작은 "부분 문제"인 거죠.
**`[5]`** 와 **`flip([1, 2, 3, 4])`**를 합쳐서 리턴해 주면 되는데요. 이것을 일반화하면 **`some_list[-1:]`**과 **`flip(some_list[:-1])`**을 더하는 것입니다.
이제 이걸 코드로 옮겨보세요.

## **해답**

```python
# 파라미터 some_list를 거꾸로 뒤집는 함수
def flip(some_list):
    # base case
    if len(some_list) == 0 or len(some_list) == 1:
        return some_list

    # recursive case
    return some_list[-1:] + flip(some_list[:-1])

# 테스트
some_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
some_list = flip(some_list)
print(some_list)
```

# 5. 하노이의 탑    *****

하노이의 탑 게임 아시나요? 이 게임의 목표는 왼쪽 기둥에 있는 원판들을 모두 오른쪽 기둥으로 옮기는 것입니다. 지켜야할 규칙은 두가지입니다:

1. 한 번에 하나의 원판만 옮길 수 있다.
2. 큰 원판이 작은 원판 위에 있어서는 안 된다.

### **과제**

하노이의 탑 게임의 해답을 출력해주는 함수 **`hanoi`**를 쓰세요. **`hanoi`**는 파라미터로 원판 수 **`num_disks`**, 게임을 시작하는 기둥 번호 **`start_peg`**, 그리고 목표로 하는 기둥 번호 **`end_peg`**를 받고, 재귀적으로 문제를 풀어 원판을 옮기는 순서를 모두 출력합니다.

```python
def move_disk(disk_num, start_peg, end_peg):
    print("%d번 원판을 %d번 기둥에서 %d번 기둥으로 이동" % (disk_num, start_peg, end_peg))

def hanoi(num_disks, start_peg, end_peg):
    # 코드를 입력하세요.

# 테스트 코드 (포함하여 제출해주세요)
hanoi(3, 1, 3)
```

```
1번 원판을 1번 기둥에서 3번 기둥으로 이동
2번 원판을 1번 기둥에서 2번 기둥으로 이동
1번 원판을 3번 기둥에서 2번 기둥으로 이동
3번 원판을 1번 기둥에서 3번 기둥으로 이동
1번 원판을 2번 기둥에서 1번 기둥으로 이동
2번 원판을 2번 기둥에서 3번 기둥으로 이동
1번 원판을 1번 기둥에서 3번 기둥으로 이동
```

가장 작은 원판의 번호는 1번이고 가장 큰 원판의 번호는 **`num_disks`**번입니다. 그리고 왼쪽 기둥이 1번, 가운데 기둥이 2번, 오른쪽 기둥이 3번입니다.

### **원판 하나인 경우**

```python
hanoi(1, 1, 3)
```

```
1번 원판을 1번 기둥에서 3번 기둥으로 이동
```

### **원판 두개인 경우**

```python
hanoi(2, 1, 3)
```

```
1번 원판을 1번 기둥에서 2번 기둥으로 이동
2번 원판을 1번 기둥에서 3번 기둥으로 이동
1번 원판을 2번 기둥에서 3번 기둥으로 이동
```

### **원판 세개인 경우**

```python
hanoi(3, 1, 3)
```

```
1번 원판을 1번 기둥에서 3번 기둥으로 이동
2번 원판을 1번 기둥에서 2번 기둥으로 이동
1번 원판을 3번 기둥에서 2번 기둥으로 이동
3번 원판을 1번 기둥에서 3번 기둥으로 이동
1번 원판을 2번 기둥에서 1번 기둥으로 이동
2번 원판을 2번 기둥에서 3번 기둥으로 이동
1번 원판을 1번 기둥에서 3번 기둥으로 이동
```

## 해답

### **힌트 1**

재귀 함수에는 recursive case와 base case가 있습니다.

- Recursive case: 현 문제가 너무 커서, 같은 형태의 더 작은 부분 문제를 재귀적으로 푸는 경우
- Base case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않고도 바로 답을 알 수 있는 경우

우선 base case가 무엇인지 생각해 볼까요?

### **힌트 2**

일단 가장 쉬운 경우는 원판이 하나도 없을 때입니다. 아무것도 안 해도 게임이 끝나겠죠?

### **힌트 3**

코드로 나타내면 이렇게 되겠습니다.

```python
def hanoi(num_disks, start_peg, end_peg):
    # base case: 옮길 원판이 없으면 부분 문제를 나누지 않고 함수를 끝낸다
    if num_disks == 0:
      return
```

그럼 원판이 하나 이상에 있는 경우, 즉 recursive case 에는 문제를 어떻게 해결할 수 있을까요?

### **힌트 4**

원판이 1개밖에 없는 경우도 쉽죠? 1번 기둥에서 3번 기둥으로 옮기면 끝납니다.

![https://i.imgur.com/h9waI4v.png](https://i.imgur.com/h9waI4v.png)

### **힌트 5**

원판이 2개인 경우는 조금 더 생각을 해야합니다. 1번 원판을 1번 기둥에서 2번 기둥으로 옮기고, 2번 원판을 1번 기둥에서 3번 기둥으로 옮기고, 1번 원판을 2번 기둥에서 3번 기둥으로 옮기면 됩니다.

![https://i.imgur.com/IhSe7p3.png](https://i.imgur.com/IhSe7p3.png)

### **힌트 6**

이제 원판 3개인 경우입니다.

![https://i.imgur.com/gti1bZV.png](https://i.imgur.com/gti1bZV.png)

일단 3번 원판이 3번 기둥에 가야하는데, 그러기 위해서는 1, 2번 원판이 2번 기둥에 가있어야겠죠? 그런데 원판 두개를 옮기는 것은 이미 '난이도 2'에서 했습니다. 그냥 그대로 따라하면 됩니다.
다만 ‘난이도 2’ 에서는 원판들을 1번 기둥에서 3번 기둥으로 옮기려고 했다면, 이번에는 1, 2번 원판들을 1번 기둥에서 3번 기둥으로 옮기는 차이가 있죠?
이걸 프로그래밍 방식으로 생각하면 **`hanoi`** 함수를 시작 기둥과 끝 기둥 인풋만 바꿔주고 재귀적으로 호출한다고 얘기할 수 있습니다. 그렇게 원판 2개를 옮겼다고 가정합시다.

![https://i.imgur.com/AWYaJvo.png](https://i.imgur.com/AWYaJvo.png)

이제 원하던대로 3번 원판을 3번 기둥으로 옮기면 됩니다.

![https://i.imgur.com/r1tQ50k.png](https://i.imgur.com/r1tQ50k.png)

마지막으로 2번 기둥에 있는 원판 두개를 3번 기둥으로 옮겨야 하는데, 이것도 '난이도 2'에서 한 것과 똑같이 하면 됩니다. 또 **`hanoi`** 함수를 부르는 셈이죠. 유일한 차이는 이번에는 1, 2번 원판을 2번 기둥에서 3번 기둥으로 옮겼다는거죠?

![https://i.imgur.com/RPe49yX.png](https://i.imgur.com/RPe49yX.png)

### **힌트 7**

원판 4개인 경우도 원판 3개인 경우랑 똑같이 생각할 수 있습니다.

![https://i.imgur.com/5TWdUK2.png](https://i.imgur.com/5TWdUK2.png)

4번 원판을 3번 기둥으로 옮기기 위해서 그 위에 원판 3개를 먼저 2번 기둥으로 옮겨야 합니다. 원판 3개를 옮기는 것은 '난이도 3'에서 한 방식 그대로 하면 됩니다.

![https://i.imgur.com/qtP5cJ7.png](https://i.imgur.com/qtP5cJ7.png)

그리고 나서 4번 원판을 3번 기둥으로 옮기고…

![https://i.imgur.com/WBxdYbV.png](https://i.imgur.com/WBxdYbV.png)

다시 '난이도 3'의 방식대로 원판 3개를 3번 기둥으로 옮기면 끝납니다.

![https://i.imgur.com/yqutGPA.png](https://i.imgur.com/yqutGPA.png)

원판들을 옮기는 과정이 이해가 되시나요?
위에서 설명한 알고리즘을 어떻게 정리할 수 있는지 생각해보세요!

### **힌트 8**

템플릿에서 **`hanoi`**함수에 들어가는 기둥 인풋들이 기억 나시나요? **`start_peg`**, **`end_peg`**였죠? 그리고 옮기려는 원판의 갯수가 **`num_disks`**입니다.
시작하는 기둥을 **`start_peg`**, 목표 기둥을 **`end_peg`**, 그리고 남는 하나의 기둥을 **`other_peg`**라고 부릅시다. 그러면 힌트 4에 나온 문제 풀이 방식을 이렇게 정리할 수 있습니다:
원래 문제가 **`num_disks`**개의 원판을  **`start_peg`**에서부터 **`end_peg`**로 옮기는 문제였다면, 문제를 풀기 위해서 사용하는 알고리즘은,

1. 가장 큰 원판을 제외하고 나머지 원판들을 **`start_peg`**에서 **`other_peg`**로 이동
2. 가장 큰 원판을 **`start_peg`**에서 **`end_peg`**로 이동
3. 나머지 원판들을 **`other_peg`**에서 **`end_peg`**로 이동

이게 우리의 recursive case가 되겠죠?

### **힌트 9**

아직도 어떻게 해야되는지 이해하시기 힘들 수가 있는데요,
일단 **`start_peg`**와 **`end_peg`**가 주어졌을 때 **`other_peg`**는 어떻게 구할까요? 1번 기둥, 2번 기둥, 3번 기둥이 있기 때문에 **`start_peg + end_peg + other_peg`**는 항상 6입니다. 따라서 **`other_peg`**는 이렇게 정의할 수 있겠네요
**`other_peg = 6 - start_peg - end_peg`**
이제 이 **`other_peg`**를 이용해서 힌트 4에 나오고 힌트 5에서 정리한 recursive case를 써볼까요?

### **해답**

```python
def move_disk(disk_num, start_peg, end_peg):
    print("%d번 원판을 %d번 기둥에서 %d번 기둥으로 이동" % (disk_num, start_peg, end_peg))

def hanoi(num_disks, start_peg, end_peg):
    # base case: 옮길 원판이 없으면 부분 문제를 나누지 않고 함수를 끝낸다
    if num_disks == 0:
        return
    else:
        other_peg = 6 - start_peg - end_peg

        # 1. 가장 큰 원판을 제외하고 나머지 원판들을 start_peg에서 other_peg로 이동
        hanoi(num_disks - 1, start_peg, other_peg)

        # 2. 가장 큰 원판을 start_peg에서 end_peg로 이동
        move_disk(num_disks, start_peg, end_peg)

        # 3. 나머지 원판들을 other_peg에서 end_peg로 이동
        hanoi(num_disks - 1, other_peg, end_peg)

# 테스트
hanoi(3, 1, 3)
```