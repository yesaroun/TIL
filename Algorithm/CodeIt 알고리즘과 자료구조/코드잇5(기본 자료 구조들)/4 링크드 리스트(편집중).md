

# 1. 링크드 리스트 개념

### 링크드 리스트(Linked List)

: 노드라는 단위의 데이터를 저장하고 데이터가 저장된 각 노드들을 순서대로 연결시켜서 만든 자료구조이다.

- 데이터를 순서대로 저장해준다.
- 요소를 계속 추가할 수 있다.

상황에 따라 링크드 리스트가 적합할때도 있고 동적 배열이 더 적합할 때도 있다. 

# 2. 링크드 리스트 프로그래밍적으로 생각하기

각 노드(Node)는 하나의 객체로 표현된다. 각 객체에는 2가지 속성이 있다. data, next이다. data 에는 우리가 저장하고 싶은 정보를 넣고 next에는 다음 노드에 대한 레퍼런스이다. 
링크드 리스트의 시작점 역할을 하는 노드를 head 노드라고 한다. 
실제 메모리에서는 노드들이 흩어져 있다.

# 3. 노드 클래스 만들기

아직 연결되지 않은 노드 생성

```python
class Node:
    '''링크드 리스트의 노드 클래스'''
    def __init__(self, data):
        self.data = data    # 노드가 저장하는 데이터
        self.next = None    # 다음 노드에 대한 레퍼런스

# 데이터 2, 3, 5, 7, 11 을 담는 노드를 생성
head_node = Node(2)
node_1 = Node(3)
node_2 = Node(5)
node_3 = Node(7)
tail_node = Node(11)
```

# 4. 간단한 링크드 리스트 만들기

```python
class Node:
    '''링크드 리스트의 노드 클래스'''
    def __init__(self, data):
        self.data = data    # 노드가 저장하는 데이터
        self.next = None    # 다음 노드에 대한 레퍼런스

# 데이터 2, 3, 5, 7, 11 을 담는 노드를 생성
head_node = Node(2)
node_1 = Node(3)
node_2 = Node(5)
node_3 = Node(7)
tail_node = Node(11)

# 노드들을 연결
head_node.next = node_1
node_1.next = node_2
node_2.next = node_3
node_3.next = tail_node

# 노드 순서대로 출력
iterator = head_node    # 반복하는것을 영어로 iterator라고 하는데 반복문으로 리스트를 돌때 도움을 주는 변수

while iterator is not None:
    print(iterator.data)
    iterator = iterator.next
'''
2
3
5
7
11
'''
```

# 5. 링크드 리스트 추가 연산

```python
class Node:
    '''링크드 리스트의 노드 클래스'''

    def __init__(self, data):
        self.data = data    # 노드가 저장하는 데이터
        self.next = None    # 다음 노드에 대한 레퍼런스

# 데이터 2, 3, 5, 7, 11 을 담는 노드를 생성
head_node = Node(2)
node_1 = Node(3)
node_2 = Node(5)
node_3 = Node(7)
tail_node = Node(11)

# 노드들을 연결
head_node.next = node_1
node_1.next = node_2
node_2.next = node_3
node_3.next = tail_node

# 링크드 리스트를 더 체계적으로 관리하게 위해서 LinkedList클래스 생성
class LinkedList:
    '''링크드 리스트 클래스'''

    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)

        if self.head is None:   # 링크드 리스트가 비어 있는 경우
            self.head = new_node
            self.tail = new_node
        else:                   # 링크드 리스트가 비어 있지 않은 경우
            self.tail.next = new_node
            self.tail = new_node

# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 링크드 리스트에 데이터 추가
my_list.append(2)
my_list.append(3)
my_list.append(5)
my_list.append(7)
my_list.append(11)

# 노드 순서대로 출력
iterator = my_list.head

while iterator is not None:
    print(iterator.data)
    iterator = iterator.next
'''
2
3
5
7
11
'''
```

# 6. 링크드 리스트 __str__ 메소드

## **__str__ 메소드**

링크드 리스트를 클래스로 만들었으니까 링크드 리스트를 문자열로 표현해주는 **`__str__`** 메소드를 정의해봅시다. **`__str__`** 메소드가 기억 안 나시는 분들은 그냥 링크드 리스트를 출력할 때 자동으로 링크드 리스트의 내용을 사람들이 이해할 수 있는 문자열로 리턴해주는 메소드로 이해하시면 됩니다.

## **링크드 리스트 __str__ 메소드**

```python
class LinkedList:
    """링크드  리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)

        # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 링크드 리스트가 비어 있지 않으면
        else:
            self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
            self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드  리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드  리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += f" {iterator.data} |"
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
```

**`__str__`** 메소드는 문자열을 리턴하니까 일단 리턴 시킬 **`res_str`** 변수를 빈 문자열로 정의합니다. **`iterator`** 을 써서 링크드 리스트를 도는 방법은 이미 배웠죠?

1. **`iterator`** 변수를 링크드 리스트의 head를 가리키게 합니다
2. **`iterator`** 변수가 **`None`** 이 아닐 때까지 (링크드 리스트의 처음부터 끝 노드까지) **`iterator`** 변수의 **`data`** 를 **`res_str`** 변수에 추가해 줍니다. **`iterator`** 변수의 **`next`** 속성을 이용해서 while 문을 돌 때마다 다음 노드로 갑니다.
3. 링크드 리스트를 다 돈 후에 **`res_str`** 변수를 리턴합니다.

한 번 제대로 코드를 작성했는지 확인해봅시다.

```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 링크드 리스트에 데이터 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)
```

영상에서와 동일하게 링크드 리스트에 노드를 추가해줬습니다.

```python
print(linked_list)  # 링크드 리스트 출력

```

그다음에 이렇게 링크드 리스트 인스턴스를 출력할 건데요. 이때 노트 위에서 정의한 **`__str__`** 메소드가 호출되는 거죠.

```
| 2 | 3 | 5 | 7 | 11 |

```

링크드 리스트의 내용이 원하는 대로 잘 출력되는군요! 앞으로 링크드 리스트에 저장되어 있는 데이터를 확인하기 위해서 **`__str__`** 메소드를 자주 쓸 건데요. 이번 노트에서 정의해놨으니까 다음 레슨들에서 그냥 자연스럽게 사용할게요.

# 7. 링크드 리스트 접근

### 링크드 리스트 접근 연산(find_node_at)

- 특정 위치에 있는 노드를 리턴하는 연산!

```python
class Node:
    '''링크드 리스트의 노드 클래스'''

    def __init__(self, data):
        self.data = data    # 노드가 저장하는 데이터
        self.next = None    # 다음 노드에 대한 레퍼런스

# 링크드 리스트를 더 체계적으로 관리하게 위해서 LinkedList클래스 생성
class LinkedList:
    '''링크드 리스트 클래스'''

    def __init__(self):
        self.head = None
        self.tail = None

    def find_node_at(self, index):
        """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정"""
        iterator = self.head

        for _ in range(index):
            iterator = iterator.next

        return iterator

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)

        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        iterator = self.head

        while iterator is not None:
            res_str += f" {iterator.data} |"
            iterator = iterator.next

        return res_str

# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 링크드 리스트에 데이터 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)

# 링크드 리스트 노드에 접근(데이터 가지고 오기)
print(linked_list.find_node_at(3).data)
#--==>> 7

# 링크드 리스트 노드에 접근 (데이터 바꾸기)
linked_list.find_node_at(2).data = 13

print(linked_list)
#--==>> | 2 | 3 | 13 | 7 | 11 |
```

### 링크드 리스트 접근 시간 복잡도

인덱스를 이용해서 링크드 리스트 노드에 접근하는 것에는 치명적인 단점이 있는데 배열에서 접근할때만큼 효율적이지 않다는 것이다.
인덱스 x에 있는 노드에 접근하려면 head에서 다음 노드로 x번 가면 된다. 
즉 배열은 인덱스와 상관없이 일정하게 한번에 접근 가능하지만 링크드 리스트에 경우 뒤에 있는 노드에 접근할 수록 드는 시간이 늘어난다. 
링크드 리스트 안에 있는 데이터 수가 n이라고 하면 최악의 경우(마지막) head에서 다음 노드로 n - 1번 가야한다. 실행되는데 걸리는 시간이 n에 비래하기 때문에
접근 연산 시간 복잡도 : O(n)이다.

# 8. 링크드 리스트 탐색 연산

탐색 연산은 자료 구조에서 원하는 조건의 데이터를 찾아내는 연산입니다.
링크드 리스트 탐색 연산은 특정 데이터를 갖는 노드를 리턴합니다.
이렇게

```
| 2 | 3 | 5 | 7 | 11
```

링크드 리스트에 **`2, 3, 5, 7, 11`** 이 저장돼 있다고 합시다. 여기서 **`5`** 를 갖는 노드를 탐색하면, 링크드 리스트 안에서 **`5`** 를 가지고 있는 노드를 찾아서 리턴하는 거죠.
배열에서 탐색 연산을 어떻게 하셨는지 기억 나시나요? 선형적으로 가장 앞부터 마지막 인덱스까지 돌면서 탐색을 했습니다. 링크드 리스트도 배열과 마찬가지로 선형 탐색을 사용합니다. 가장 앞 노드부터 끝 노드까지 돌면서 원하는 데이터를 갖는 노드를 리턴하죠.
이번 과제에서는 링크드 리스트의 탐색 연산을 직접 구현해볼게요.
메소드 **`find_node_with_data`** 는 찾으려는 데이터를 파라미터 **`data`** 로 받아서 링크드 리스트 내에서 원하는 데이터를 갖고 있는 노드를 리턴합니다.
단, 원하는 데이터가 링크드 리스트 안에 없을 때는 **`None`** 을 리턴합니다.

### **출력 예시**

```
2
11
6을 갖는 노드는 없습니다
```

### 초기 값

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스

class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def find_node_with_data(self, data):
        """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
        # 코드를 쓰세요

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)
        
        # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 링크드 리스트가 비어 있지 않으면
        else:
            self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
            self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다

    def __str__(self):
        """링크드  리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드  리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드  리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += " {} |".format(iterator.data)
            iterator = iterator.next # 다음 노드로 넘어간다

        return res_str
    
    

# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 마지막에 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)

# 데이터 2를 갖는 노드 탐색
node_with_2 = linked_list.find_node_with_data(2)

if not node_with_2 is None:
    print(node_with_2.data)
else:
    print("2를 갖는 노드는 없습니다")

# 데이터 11을 갖는 노드 탐색
node_with_11 = linked_list.find_node_with_data(11)

if not node_with_11 is None:
    print(node_with_11.data)
else:
    print("11를 갖는 노드는 없습니다")

# 데이터 6 갖는 노드 탐색
node_with_6 = linked_list.find_node_with_data(6)

if not node_with_6 is None:
    print(node_with_6.data)
else:
    print("6을 갖는 노드는 없습니다")
```

## 해답

해설 노트에서 링크드 리스트 클래스를 전부 다 보여주기에는 공간이 너무 많이 차지되기 때문에 과제마다 해당 메소드와 실행 코드만 보여드리겠습니다!

### **find_node_with_data 메소드**

```python
    def find_node_with_data(self, data):
        """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
        iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수
```

링크드 리스트를 처음부터 끝까지 돌 때는 **`__str__`** 메소드나 **`find_node_at`** 메소드를 쓸 때랑 똑같이 **`iterator`** 변수를 사용합니다. 처음에 **`iterator`** 변수는 링크드 리스트의 헤드 노드를 가리키게 합니다.

```python
        # 링크드 리스트 전체를 돈다
        while iterator is not None:
            # iterator 노드의 데이터가 찾는 데이터면 iterator를 리턴한다
            if iterator.data == data:
                return iterator
            iterator = iterator.next  # 다음 노드로 넘어간다
```

그리고 링크드 리스트를 도는데요. while문을 이용해서 head에서 tail 노드까지 돕니다. **`iterator`** 변수가 반복문을 돌 때마다 다음 순서에 있는 노드를 가리키는데요. **`iterator`** 가 **`None`** 이면 더이상 다음 노드가 없다는 말, 그러니까 링크드 리스트 끝까지 도달했다는 뜻입니다

반복문 안에서는 if 문을 사용해서 현재 보고 있는 노드 **`iterator`** 변수의 속성이 파라미터로 받은 **`data`** 인지 확인해줍니다. 맞다면 **`iterator`** 변수, 즉 현재 돌면서 확인하고 있는 노드를 리턴하는 거죠.

```python
        # 링크드 리스트 안에 원하는 데이터가 없었기 때문에 None 리턴한다
        return None
```

링크드 리스트의 모든 노드를 다 돌았는데 원하는 조건의 노드를 못 찾은 경우는 뭘까요? 원하는 조건의 노드가 링크드 리스트 안에 없다는 거죠. 이 때는 **`None`** 을 리턴합니다.

### **해답 코드 정리**

```python
def find_node_with_data(self, data):
    """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

    # 링크드 리스트 전체를 돈다
    while iterator is not None:
        # iterator 노드의 데이터가 찾는 데이터면 iterator를 리턴한다
        if iterator.data == data:
            return iterator
        iterator = iterator.next  # 다음 노드로 넘어간다

    # 링크드 리스트 안에 원하는 데이터가 없었기 때문에 None 리턴한다
    return None
```

# **실행 코드**

제대로 동작하는지 실행 코드를 돌려보면:

```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 마지막에 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)

# 데이터 2를 갖는 노드 탐색
node_with_2 = linked_list.find_node_with_data(2)

if not node_with_2 is None:
    print(node_with_2.data)
else:
    print("2를 갖는 노드는 없습니다")

# 데이터 11을 갖는 노드 탐색
node_with_11 = linked_list.find_node_with_data(11)

if not node_with_11 is None:
    print(node_with_11.data)
else:
    print("11를 갖는 노드는 없습니다")

# 데이터 6 갖는 노드 탐색
node_with_6 = linked_list.find_node_with_data(6)

if not node_with_6 is None:
    print(node_with_6.data)
else:
    print("6을 갖는 노드는 없습니다")
```

결과가 제대로 출력되는 걸 확인할 수 있습니다.

```
2
11
6을 갖는 노드는 없습니다
```

# 9. 링크드 리스트 삽입 연산

```python
class Node:
    """링크드 리스트의 노드 클래스"""

    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스

class LinkedList:
    """링크드 리스트 클래스"""

    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def insert_after(self, previous_node, data):
        """링크드 리스트 주어진 노드 뒤 삽입 연산 메소드"""
        new_node = Node(data)

        # 가장 마지막 순서 삽입
        if previous_node is self.tail:
            self.tail.next = new_node
            self.tail = new_node
        else:   # 두 노드 사이에 삽입
            new_node.next = previous_node.next
            previous_node.next = new_node

    def find_node_with_data(self, data):
        """링크드 리스트에서 탐색 연산 메소드. 단, 해당 노드가 없으면 None을 리턴한다"""
        iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

        # 링크드 리스트 전체를 돈다
        while iterator is not None:
            # iterator 노드의 데이터가 찾는 데이터면 iterator를 리턴한다
            if iterator.data == data:
                return iterator
            iterator = iterator.next  # 다음 노드로 넘어간다

        # 링크드 리스트 안에 원하는 데이터가 없었기 때문에 None 리턴한다
        return None

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)

        # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 링크드 리스트가 비어 있지 않으면
        else:
            self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
            self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다

    def __str__(self):
        """링크드  리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드  리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드  리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += " {} |".format(iterator.data)
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str

# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 마지막에 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)

print(linked_list)
#--==>> | 2 | 3 | 5 | 7 |

node_2 = linked_list.find_node_with_data(2)     # 인덱스 2에 있는 노드 접근
linked_list.insert_after(node_2, 6)             # 인덱스 2 뒤에 6 삽입

print(linked_list)
#--==>> | 2 | 6 | 3 | 5 | 7 |

head_node = linked_list.head    # 헤드 노드 접근
linked_list.insert_after(head_node, 9)  # 헤드 노드 뒤에 9 삽입

print(linked_list)
#--==>> | 2 | 9 | 6 | 3 | 5 | 7 |
```

# 10. prepend: 링크드 리스트 가장 앞 삽입

저번 레슨에서는 링크드 리스트에서 주어진 노드 뒤에 새로운 노드를 삽입하는 연산을 배웠는데요. 이 연산을 메소드로 구현했을 때는 **`insert_after`** 메소드로 구현했습니다.
사실 이 연산에는 한 가지 흠이 있는데요. 이 연산은 항상 주어진 노드 다음에 노드를 삽입하잖아요? 파라미터로 가장 앞 노드 head를 넘겨줘도 head 노드 앞에는 새로운 노드를 추가할 수 없습니다. 링크드 리스트 가장 앞에는 삽입할 수 없다는 거죠.
이 문제를 해결해주는 새로운 메소드를 정의해줍시다. 이 메소드는 **`prepend`** 라고 부르고요, 파라미터로 데이터 **`data`** 를 받아서 링크드 리스트의 가장 앞에 데이터를 **`data`** 로 갖는 새로운 노드를 추가시켜줍니다.

- *주의: **`prepend`** 메소드를 작성할 때 링크드 리스트가 비어 있는 경우도 생각해서 작성하셔야 됩니다!

### **출력 예시**

```
| 2 | 3 | 5 | 7 | 11 |
2
11
```

### 초기 코드

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스

class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def prepend(self, data):
        """링크드 리스트의 가장 앞에 데이터 삽입"""
        # 코드를 쓰세요

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += f" {iterator.data} |"
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
    
    

# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
linked_list.prepend(11)
linked_list.prepend(7)
linked_list.prepend(5)
linked_list.prepend(3)
linked_list.prepend(2)

print(linked_list)  # 링크드 리스트 출력

# head, tail 노드가 제대로 설정됐는지 확인
print(linked_list.head.data)
print(linked_list.tail.data)
```

## 해답

### **새로운 노드 만들기**

```python
    def prepend(self, data):
        """링크드 리스트의 가장 앞에 데이터 삽입"""
        new_node = Node(data)  # 새로운 노드를 만든다
```

링크드 리스트에 새로운 데이터를 더해줄 때는 항상 그 데이터를 저장하는 새로운 노드를 만듭니다. 파라미터 **`data`** 를 저장하는 노드를 만들고 변수 **`new_node`** 에 저장해줄게요.

### **경우 1: 링크드 리스트가 비었을 때**

```python
        # 링크드 리스트가 비었는지 확인
        if self.head is None:
            # 새 노드를 링크드 리스트의 유일한 노드로 만들어준다
            self.head = new_node
            self.tail = new_node
```

그다음에는 링크드 리스트가 빈 경우를 생각해볼게요. 링크드 리스트가 비었는지 안 비었는지는 head 노드가 비었는지를 확인하면 알 수 있습니다. **`if self.head is None:`** 을 쓰면 확인할 수 있죠.
이 경우에서는 **`append`** 메소드에서 했던 것과 똑같이 새로 만든 노드를 링크드 리스트의 처음이자 마지막 노드로 만들어줍니다.

### **경우 2: 링크드 리스트가 안 비었을 때**

```python
        else:
            new_node.next = self.head  # 새로운 노드의 다음 노드를 head 노드로 정해주고
            self.head = new_node  # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다
```

그다음에는 링크드 리스트 안에 이미 데이터가 있는 경우를 처리합니다. 경우가 2 개밖에 없으니까 else 문을 사용합니다.
head 노드를 **`new_node`** 의 다음 노드로 지정한 후, 링크드 리스트의 가장 앞 노드가 바꼈으니까 **`self.head`** 속성도 **`new_node`** 를 가르키도록 바꿔줍니다.
위에 쓴 코드를 정리하면 아래같이 쓸 수 있겠죠?

### **해답 코드 정리**

```python
def prepend(self, data):
    """링크드 리스트의 가장 앞에 데이터 삽입"""
    new_node = Node(data)  # 새로운 노드를 만든다

    # 링크드 리스트가 비었는지 확인
    if self.head is None:
        # 새 노드를 링크드 리스트의 유일한 노드로 만들어준다
        self.head = new_node
        self.tail = new_node
    else:
        new_node.next = self.head  # 새로운 노드의 다음 노드를 head 노드로 정해주고
        self.head = new_node  # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다
```

여기 사실 코드를 좀 더 짧게 해주기 위해서 해줄 수 있는 게 있는데요. if - else 문을 보면 **`self.head`** 변수가 **`new_node`** 를 가리키게 하는 건 링크드 리스트가 비어있던 아니던 항상 실행되는 코드입니다. 그래서 이렇게도 써줄 수도 있습니다.

```python
def prepend(self, data):
    """링크드 리스트의 가장 앞에 데이터 삽입"""
    new_node = Node(data)   # 새로운 노드를 만든다

    # 링크드 리스트가 비었는지 확인
    if self.head is None:
        self.tail = new_node
    else:
        new_node.next = self.head  # 새로운 노드의 다음 노드를 head 노드로 정해주고

    self.head = new_node  # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다
```

둘 다 실행되는 건 정확히 똑같은 코드입니다. 아래 코드는 좀 더 짧고 위 코드는 읽기 편하고 이해하기 좀 더 편하다는 차이가 있는데요. 본인의 성향과 필요에 맞게 골라서 사용하면 됩니다.

### **실행 코드**

코드를 다 썼으니까 제대로 돌아가는지 확인해봅시다.

```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
linked_list.prepend(11)
linked_list.prepend(7)
linked_list.prepend(5)
linked_list.prepend(3)
linked_list.prepend(2)

print(linked_list)  # 링크드 리스트 출력

# head, tail 노드가 제대로 설정됐는지 확인
print(linked_list.head.data)
print(linked_list.tail.data)
```

잘 출력되는 걸 확인할 수 있습니다.

```
| 2 | 3 | 5 | 7 | 11 |
2
11
```

# 11. 링크드 리스트 삭제

```python
def delete_after(self, previous_node):
        """링크드 리스트 삭제연산. 주어진 노드 뒤 노드를 삭제한다."""
        data = previous_node.next.data

        # 지우려는 노드가 tail 노드일 때:
        if previous_node.next is self.tail:
            previous_node.next = None
            self.tail = previous_node
        else:
            previous_node.next = previous_node.next.next

        return data
```

```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 마지막에 추가
linked_list.append(2)
linked_list.append(3)
linked_list.append(5)
linked_list.append(7)
linked_list.append(11)

print(linked_list)

node_2 = linked_list.find_node_at(2)    # 인덱스 2노드 접근
linked_list.delete_after(node_2)        # 인덱스 2 뒤 데이터 삭제

print(linked_list)

second_to_last_node = linked_list.find_node_at(2)   # 맨 끝에서 두 번째 노드 접근
print(linked_list.delete_after(second_to_last_node)) # tail노드 삭제

print(linked_list)
"""
| 2 | 3 | 5 | 7 | 11 |
| 2 | 3 | 5 | 11 |
11
| 2 | 3 | 5 |
"""
```

# 12. popleft: 링크드 리스트 가장 앞 삭제

바로 전 레슨에서 배운 삭제는 삽입과 마찬가지의 문제가 있는데요. 주어진 노드의 다음 노드를 삭제하기 때문에 head 노드를 삭제할 수 없습니다. 전과 마찬가지로 head 노드도 지울 수 있도록 메소드를 추가하겠습니다.
메소드 **`pop_left`** 는 파라미터로 **`self`** 이외에 아무것도 받지 않으며, 링크드 리스트의 head 노드를 삭제해줍니다. **`pop_left`** 메소드는 링크드 리스트에서 삭제하는 노드의 데이터를 리턴합니다.

- 주의:
- **`pop_left`** 메소드를 호출함으로 인해서 링크드 리스트가 비어지는 경우를 생각해서 작성하셔야 됩니다! (지우려는 노드가 링크드 리스트의 마지막 남은 노드일 때)
- **`pop_left`** 를 호출할 때 링크드 리스트가 비어 있는 경우는 없다고 가정해도 됩니다.
- **`pop_left`** 메소드는 삭제하는 노드의 데이터를 리턴합니다.

### **출력 예시**

```
2
3
5
7
11
|
None
None
```

### 초기 코드

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스
        
        
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def pop_left(self):
        """링크드 리스트의 가장 앞 노드 삭제 메소드. 단, 링크드 리스트에 항상 노드가 있다고 가정한다"""
        # 코드를 쓰세요

    def prepend(self, data):
        """링크드 리스트의 가장 앞에 데이터 삽입"""
        new_node = Node(data)  # 새로운 노드를 만든다

        # 링크드 리스트가 비었는지 확인
        if self.head is None:
            self.tail = new_node
        else:
            new_node.next = self.head  # 새로운 노드의 다음 노드를 head 노드로 정해주고

        self.head = new_node  # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += f" {iterator.data} |"
            iterator = iterator.next # 다음 노드로 넘어간다

        return res_str
    
    

# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
linked_list.prepend(11)
linked_list.prepend(7)
linked_list.prepend(5)
linked_list.prepend(3)
linked_list.prepend(2)

# 가장 앞 노드 계속 삭제
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())

print(linked_list)  # 링크드 리스트 출력
print(linked_list.head)
print(linked_list.tail)
```

## 해답

### **경우 1: 삭제하려는 노드가 마지막 남은 노드일 때**

```python
    def pop_left(self):
        """링크드 리스트의 가장 앞 노드 삭제 메소드. 단, 링크드 리스트에 항상 노드가 있다고 가정한다"""
        # 지우려는 데이터가 링크드 리스트의 마지막 남은 데이터일 때
        if self.head is self.tail:
            self.head = None
            self.tail = None
```

링크드 리스트에 하나의 노드만 남은 경우는 가장 앞 노드가 동시에 가장 마지막 노드인 경우입니다. 이 경우는 **`if self.head is self.tail`** 의 if 문으로 찾을 수 있습니다.
이 경우에는 링크드 리스트에 남은 노드가 하나도 없게 해야 됩니다. head와 tail 속성을 모두 **`None`** 을 가르키게 하면 되죠.

### **경우 2: 삭제하려는 노드가 마지막 남은 노드가 아닐 때**

```python
        else:
            # 링크드 리스트의 head를 지금 head의 다음 노드로 지정해준다
            self.head = self.head.next
```

경우가 두 개밖에 없기 때문에 else 문을 사용해서 두 번째 경우를 찾습니다.
head 노드를 더 이상 찾을 수 없게 해주는 동시에 인덱스 1에 있는 노드를 head로 만들어줘야 되는데요. 이때 그냥 **`self.head`** 속성이 현재 head 노드의 다음 노드를 가리키게 하면 됩니다. 그럼 링크드 리스트 안에 원래 head 노드를 가리키는 레퍼런스는 없어지고, 링크드 리스트의 가장 앞 노드가 한 순서 뒤로 밀렸으니까 head 노드를 삭제했다고 할 수 있겠죠?

### **삭제하는 데이터 리턴**

```python
    def pop_left(self):
        """링크드 리스트의 가장 앞 노드 삭제 메소드. 단, 링크드 리스트에 항상 노드가 있다고 가정한다"""
        data = self.head.data  # 삭제할 노드를 미리 저장해놓는다

        # 지우려는 데이터가 링크드 리스트의 마지막 남은 데이터일 때
        if self.head is self.tail:
            self.head = None
            self.tail = None
        else:
            self.head = self.head.next

        return data  # 삭제된 노드의 데이터를 리턴한다
```

이렇게 메소드 가장 위 부분에 삭제하는 노드의 데이터를 변수에 저장하고, 마지막에 리턴해주면 됩니다.

### **실행 코드**

```python
# 새로운 링크드 리스트 생성
linked_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
linked_list.prepend(11)
linked_list.prepend(9)
linked_list.prepend(5)
linked_list.prepend(3)
linked_list.prepend(2)

print(linked_list) # 링크드 리스트 출력

# 가장 앞 노드 계속 삭제
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())
print(linked_list.pop_left())

print(linked_list) # 링크드 리스트 출력
print(linked_list.head)
print(linked_list.tail)
```

### **출력 내용**

```
2
3
5
7
11
|
None
None
```

# 13. 링크드 리스트 시간 복잡도

## **링크드 리스트 연산들 시간 복잡도**

이번 챕터 내내 링크드 리스트가 무엇이고 어떤 연산들을 할 수 있는지 봤는데요. 접근, 탐색, 삽입, 그리고 삭제 연산들을 봤습니다. 이 네 개의 연산들의 시간 복잡도를 평가해볼게요.

### **접근**

접근부터 봅시다. 사실 접근은 이미 시간 복잡도를 알아봤는데요. 복습하는 느낌으로 볼게요. 인덱스 x에 있는 데이터에 접근하려면 링크드 리스트의 head 노드부터 x 번 다음 노드를 찾아서 가야 됩니다.
원하는 노드에 접근하는 시간은 몇 번째 인덱스인지에 비례하는 건데요.
그러니까 인덱스 1에 있는 노드는 head 노드에서 한 번만 다음 노드로 가면 되고 인덱스 5에 있는 노드는 head 노드에서 연속해서 5 번 이동하면 되는 거죠. 링크드 리스트 안에 있는 노드의 수를 n이라고 하면, 마지막 순서에 있는 노드에 접근해야 되는 최악의 경우에는 head 노드에서 총 n - 1 번 다음 노드로 가야 됩니다. 걸리는 시간은 n에 비례하기 때문에 접근 연산은 최악의 경우 O(n)의 시간 복잡도를 갖습니다.

## **탐색**

링크드 리스트 탐색 연산은 배열을 탐색할 때와 같은 방법으로 합니다. 가장 앞 노드부터 다음 노드를 하나씩 보면서 원하는 데이터를 갖는 찾습니다. 이런 탐색 방법을 선형 탐색이라고 했는데요. 접근과 마찬가지로 링크드 리스트 안에 찾는 데이터가 없을 때 또는 찾으려는 데이터가 마지막 노드에 있는 최악의 경우, n 개의 노드를 모두 다 봐야 됩니다. 그렇기 때문에 탐색도 접근과 마찬가지로 최악의 경우 O(n)의 시간 복잡도를 갖습니다.

## **삽입/삭제**

링크드 리스트의 삽입과 삭제 연산은 배열 삽입과 조금 차이가 있었는데요. **`insert_after`**, **`delete_after`** 메소드들을 한 번 살펴보세요.

```python
def insert_after(self, previous_node, data):
    """파라미터 data를 데이터로 갖는 새로운 노드를 만들어서 node 파라미터 뒤에 삽입시킨"""
    new_node = Node(data) # 새로운 노드 만들기

    # tail 노드 다음에 새로운 노드를 삽입할 때
    if previous_node == self.tail:
        previous_node.next = new_node
        self.tail = new_node
    # 두 노드 사이에 새로운 노드를 삽입할 때
    else:
        new_node.next = previous_node.next
        previous_node.next = new_node

def delete_after(self, previous_node):
    """파라미터로 받은 노드 다음 노드를 삭제한다. 단, 파라미터 previous노드로 인해서 에러는 안 난다고 가정한다"""
    data = previous_node.next.data

    # 지우려는 노드가 tail 노드일 때
    if previous_node.next == self.tail:
        self.tail = previous_node
        self.tail.next = None
    # 두 노드 사이의 노드를 지울
    else:
        previous_node.next = previous_node.next.next

    return data
```

삽입, 삭제는 그냥 삽입, 삭제할 인덱스의 주변 노드들에 연결된 레퍼런스만 수정합니다
그러니까 이 연산들이 실행되는데 걸리는 시간은 특정 값에 비례하지 않고 항상 일정하다는 말인데요. 파라미터로 받는 이 노드가 어떤 순서에 있는 노드든 상관없이 걸리는 시간은 변하지 않는 거죠. O(1)의 시간 복잡도를 갖는다고 할 수 있습니다.

## **시간 복잡도**

모든 걸 종합해보면 이렇게 나타낼 수 있습니다.

|연산 |시간 복잡도|
| --- | --- |
|접근|O(n)|
|탐색|O(n)|
|삽입|O(1)|
|삭제|O(1)|

접근과 탐색은 O(n), 삽입과 삭제는 O(1)이죠.

## **현실적인 삽입/삭제 시간 복잡도**

하지만 조금 더 현실적으로 생각해봅시다. 삽입과 삭제 연산들은 특정 노드를 넘겨줘서 이 노드 다음 순서에 데이터를 삽입하거나 삭제했잖아요? 그럼 이 연산들에 넘겨주는 노드, 파라미터 **`previous_node`** 를 먼저 찾아야 되는데요. head와 tail 노드는 항상 저장해주기 때문에 빨리 찾을 수 있는데, 나머지 노드들은 탐색이나 접근 연산을 통해서 가지고 와야 됩니다.
그러니까 현실적으로는 이렇게 되는 거죠.

|연산|링크드 리스트|
|--|--|
|접근|O(n)|
|탐색|O(n)|
|원하는 노드에 접근 또는 탐색 + 삽입|O(n + 1)|
|원하는 노드에 접근 또는 탐색 + 삭제|O(n + 1)|

사실상 삽입과 삭제 연산은 접근 또는 탐색의 시간 복잡도인 O(n)를 공유한다고 볼 수 있습니다.

## **삽입 삭제 연산 특수 경우 시간 복잡도**

근데 아까 얘기했듯이, head와 tail 노드는 항상 한 번에 찾을 수 있었죠? 접근하는데 O(1), 연산을 하는데 O(1)이 걸리는데요. 그렇기 때문에 이 두 노드와 관련. 있는 삽입이나 삭제 연산들은 O(1)로 할 수 있습니다.
**`append`**, **`prepend`**, **`pop_left`** 메소드를 살펴보면 head 노드와 tail 노드를 한 번에 가지고 와서 레퍼런스를 바꿔주죠?

```python
def pop_left(self):
    """링크드 리스트의 가장 앞 노드를 삭제해주는 메소드, 단 링크드 리스트에 항상 노드가 있다고 가정한다"""
    data = self.head.data  # 삭제할 노드를 미리 저장해놓는다

    # 지우려는 데이터가 링크드 리스트의 마지막 남 데이터일 때
    if self.head is self.tail:
        self.head = None
        self.tail = None
    else:
        self.head = self.head.next

    return data  # 삭제된 노드의 데이터를 리턴한다

def prepend(self, data):
    """링크드 리스트의 가장 앞에 데이터 삽입"""
    new_node = Node(data)  # 새로운 노드를 만든다

    # 링크드 리스트가 비었는지 확인
    if self.head is None:
        self.tail = new_node
    else:
        new_node.next = self.head   # 새로운 노드의 다음 노드를 head 노드로 정해주고

    self.head = new_node   # 리스트의 head_node를 새롭게 삽입한 노드로 정해준다

def append(self, data):
    """파라미터로 받은 데이터를 갖는 노드를 생성한다"""
    new_node = Node(data)

    # 링크드 리스트가 비어 있으면 새로운 노드가 링크드 리스트의 처음이자 마지막 노드다
    if self.head == None:
        self.head = new_node
        self.tail = new_node
    # 링크드 리스트가 비어 있지 않으면
    else:
        self.tail.next = new_node  # 가장 마지막 노드 뒤에 새로운 노드를 추가하고
        self.tail = new_node  # 마지막 노드를 추가한 노드로 바꿔준다
```

링크드 리스트 안에 몇 개의 노드가 있던 상관없이, 항상 한 번에 받아와서 레퍼런스를 바꿔줍니다.
이렇게 표현할 수 있겠네요.

| --- | --- |

양 끝에서 하는 삽입/삭제 연산들 중 유일하게 tail 노드를 삭제하는 경우는 빠졌죠?
tail 노드를 삭제하기 위해서는 바로 전 노드가 필요한데요. 이 노드를 찾으려면 head 노드에서 n - 2번 다음 노드로 가야 됩니다. 접근하는데 O(n - 2), 그러니까 O(n)의 시간 복잡도가 걸립니다. 접근한 노드에서 다음 노드를 삭제하는 건 O(1)이 걸리잖아요?. 그러니까 tail 노드 전 노드에 접근해서 tail 노드를 삭제하는 건 O(n + 1), 결국 O(n) 인 거죠.

| --- | --- |

링크드 리스트 가장 뒤 노드 삭제 연산은 나머지 세 연산만큼 효율적으로 할 수 없습니다.

# 14. 더블리 링크드 리스트

각 노드가 다음 노드는 물론이고 바로 전 노드의 레퍼런스까지 저장한다.
싱글리 링크드 리스트 노드는 노드에 저장하려는 정보 data와 다음 노드에 대한 래퍼런스 next를 저장했다.
더블리 링크드 리스트는 여기서 전 노드에 대한 래퍼런스 prev만 더 추가한다.
아래처럼 생성

```python
class Node:
    """더블리 링크드 리스트 노드"""
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class LinkedList:
    """더블리 링크드 리스트"""
    def __init__(self):
        self.head = None
        self.tail = None
```

# 15. 더블리 링크드 리스트 겹치는 메소드

## **더블리 링크드 리스트 겹치는 연산들**

사실 더블리 링크드 리스트는 **`__init__`** 메소드 말고도 싱글리 링크드 리스트에서 안 바꿔도 되는 메소드들이 좀 있는데요.
구체적으로 말하면 **`find_node_at`**(접근 연산), **`find_node_with_data`**(탐색 연산), 그리고 **`__str__`**  메소드가 싱글리 링크드 리스트랑 겹칩니다.
그래서 더블리 링크드 리스트를 배울 때도 이 메소드들은 이미 있다는 가정하에 배울 건데요. 참고하시기 편하게 아래에 메소드 별로 적어놨습니다.
혹시 이번 노트에서 보시는 메소드 중에서 이해가 안 되는 부분이 있으면 챕터 앞 부분의 레슨들을 복습하시고 넘어가시는 걸 추천드릴게요.

### **접근**

```python
def find_node_at(self, index):
    """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정한다"""

    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

    # index 번째 있는 노드로 간다
    for _ in range(index):
        iterator = iterator.next

    return iterator
```

### **탐색**

```python
def find_node_with_data(self, data):
    """링크드 리스트에서 주어진 데이터를 갖고있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
    iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

    while iterator is not None:
        if iterator.data == data:
            return iterator

        iterator = iterator.next

    return None
```

### **`__str__` 메소드**

```python
def __str__(self):
    """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
    res_str = "|"

    # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
    iterator = self.head

    # 링크드 리스트 끝까지 돈다
    while iterator is not None:
        # 각 노드의 데이터를 리턴하는 문자열에 더해준다
        res_str += " {} |".format(iterator.data)
        iterator = iterator.next  # 다음 노드로 넘어간다

    return res_str
```

# 16. 더블리 링크드 리스트 추가 연산

```python
def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)   # 새로운 데이터를 저장하는 노드

        # 링크드 리스트가 비어 있는 경우
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:       # 링크드 리스트에 데이터가 이미 있는 경우
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node
```

```python
# 빈 링크드 리스트 정의
my_list = LinkedList()

# 링크드 리스트에 데이터 추가
my_list.append(2)
my_list.append(3)
my_list.append(5)
my_list.append(7)

print(my_list)
#--==>> | 2 | 3 | 5 | 7 |
```

# 18. 더블리 링크드 리스트 삽입 연산 구현

저번 영상에서는 더블리 링크드 리스트에 노드 삽입을 어떻게 하는지 두 개의 경우를 나눠서 봤는데요. 이번 과제에서는 영상에서 배운 내용을 바탕으로 직접 삽입 연산을 하는 메소드 **`insert_after`**를 써볼게요.
**`insert_after`** 메소드는 파라미터로 노드 **`previous_node`**와 삽입할 정보 **`data`**를 받습니다. 그리고 **`previous_node`** 다음 위치에 **`data`**를 저장하는 노드를 삽입합니다.
**`insert_after`** 메소드를 직접 코드로 구현해보세요!

### **출력 예시**

```
| 2 | 3 | 5 | 7 | 11 |
| 2 | 3 | 5 | 7 | 11 | 5 |
5
| 2 | 3 | 5 | 7 | 3 | 11 | 5 |
| 2 | 3 | 5 | 2 | 7 | 3 | 11 | 5 |
```

### 초기 코드

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스
        
        
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def insert_after(self, previous_node, data):
        """링크드 리스트 추가 연산 메소드"""
        # 코드를 쓰세요
        
    def find_node_at(self, index):
        """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정한다"""

        iterator = self.head # 링크드 리스트를 돌기 위해 필요한 노드 변수

        # index 번째 있는 노드로 간다
        for _ in range(index):
            iterator = iterator.next

        return iterator

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)  # 새로운 노드 생성

        # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 이미 노드가 있으면
        else:
            self.tail.next = new_node  # 마지막 노드의 다음 노드로 추가
            new_node.prev = self.tail
            self.tail = new_node  # 마지막 노드 업데이

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += " {} |".format(iterator.data)
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
    
    

# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 새로운 노드 5개 추가
my_list.append(2)
my_list.append(3)
my_list.append(5)
my_list.append(7)
my_list.append(11)

print(my_list)

# tail 노드 뒤에 노드 삽입
tail_node = my_list.tail  # 4 번째(마지막)노드를 찾는다
my_list.insert_after(tail_node, 5)  # 4 번째(마지막)노드 뒤에 노드 추가
print(my_list)
print(my_list.tail.data)  # 새로운 tail 노드 데이터 출력

# 링크드 리스트 중간에 데이터 삽입
node_at_index_3 = my_list.find_node_at(3)  # 노드 접근
my_list.insert_after(node_at_index_3, 3)
print(my_list)

# 링크드 리스트 중간에 데이터 삽입
node_at_index_2 = my_list.find_node_at(2)  # 노드 접근
my_list.insert_after(node_at_index_2, 2)
print(my_list)
```

## 해설

### **새로운 노드 생성**

```python
    def insert_after(self, previous_node, data):
        """주어진 노드 다음에 데이터를 추가시켜주는 메소드"""
        new_node = Node(data)  # 새로운 노드 생성
```

링크드 리스트에 새로운 데이터를 더해줄 때는 항상 그 데이터를 저장하는 새로운 노드를 만듭니다. 파라미터 **`data`**를 저장하는 노드를 만들고 변수 **`new_node`**에 저장해줄게요.

### **경우 1: tail 노드 뒤에 삽입할 때:**

```python
        # tail 노드 다음에 노드를 삽입할 때
        if previous_node is self.tail:
            self.tail.next = new_node  # 새로운 노드를 tail 노드의 다음 노드로 지정한다
            new_node.prev = self.tail  # tail 노드를 새로운 노드의 전 노드로 지정한다
            self.tail = new_node  # 새로운 노드를 tail 노드로 지정한다
```

먼저 tail 노드 뒤에 데이터를 삽입하는 경우부터 봅시다. tail 노드 뒤에 삽입하는 경우는 **`insert_after`** 메소드가 파라미터로 받은 **`previous_node`**가 tail 노드인지 확인합니다. **`insert_after`** 메소드는 **`previous_node`** 뒤에 새로운 노드를 삽입하잖아요? 그러니까 **`previous_node`**가 tail 노드인지 확인하면 tail 노드 뒤에 삽입하는 경우인지를 알 수 있는 거죠.
이 경우에는 **`new_node`**를 기존 tail 노드와 연결시켜주고, tail 노드를 **`new_node`**로 만들어 주면 됩니다.

영상에서 봤듯이:

1. 새로운 노드를 tail 노드의 다음 노드로 지정한다
2. tail 노드를 새로운 노드의 전 노드로 지정한다
3. 새로운 노드를 tail 노드로 지정한다

이 세 가지를 해주면 되죠.

### 경우 2: 두 노드 사이에 삽입할 때:

```python
        else:
            # 새롭게 생성한 노드를 이미 있는 링크드 리스트에 연결시키고
            new_node.prev = previous_node
            new_node.next = previous_node.next

            # 이미 있는 노드들의 앞과 다음 레퍼런스를 새롭게 생성한 노드로 지정한다
            previous_node.next.prev = new_node
            previous_node.next = new_node
```

두 노드 사이에 삽입하는 경우는 else 문을 써서 처리해줍니다. 이 경우는 새롭게 만든 노드를 링크드 리스트에 연결하고, 링크드 리스트에 있는 노드들을 새롭게 만든 노드에 연결하면 됩니다.

1. 새롭게 만든 노드를 링크드 리스트에 연결시킨다
    1. **`new_node`**를 **`previous_node`**의 다음 노드로 지정한다
    2. **`new_node`**를 **`previous_node`**의 다음 노드의 전 노드로 지정한다
2. 이미 있던 노드들에 새롭게 만든 노드를 연결시킨다
    1. **`previous_node`**의 다음 노드의 전 노드를 **`new_node`**로 지정한다
    2. **`previous_node`**의 다음 노드를 **`new_node`**로 지정한다

이 네 가지를 해주면 되는 거죠.

### **해답 코드 정리**

```python
    def insert_after(self, previous_node, data):
        """주어진 노드 다음에 데이터를 추가시켜주는 메소드"""
        new_node = Node(data)  # 새로운 노드 생성

        # tail 노드 다음에 노드를 삽입할 때
        if previous_node is self.tail:
            self.tail.next = new_node  # 새로운 노드를 tail 노드의 다음 노드로 지정한다
            new_node.prev = self.tail  # tail 노드를 새로운 노드의 전 노드로 지정한다
            self.tail = new_node  # 새로운 노드를 tail 노드로 지정한다

        else:
            # 새롭게 생성한 노드를 이미 있는 링크드 리스트에 연결시키고
            new_node.prev = previous_node
            new_node.next = previous_node.next

            # 이미 있는 노드들의 앞과 다음 레퍼런스를 새롭게 생성한 노드로 지정한다
            previous_node.next.prev = new_node
            previous_node.next = new_node
```

### **실행 코드**

```python
tail_node = my_list.tail  # tail 노드
my_list.insert_after(tail_node, 6)  # tail 노드 뒤에 노드 추가
print(my_list)
print(my_list.tail.data)  # 새로운 tail 노드 데이터 출력

# 링크드 리스트 중간에 데이터 삽입
node_at_index_3 = my_list.find_node_at(3)  # 노드 접근
my_list.insert_after(node_at_index_3, 3)
print(my_list)

# 링크드 리스트 중간에 데이터 삽입
node_at_index_2 = my_list.find_node_at(2)  # 노드 접근
my_list.insert_after(node_at_index_2, 2)
print(my_list)
```

```
| 2 | 3 | 5 | 7 | 11 |
| 2 | 3 | 5 | 7 | 11 | 5 |
5
| 2 | 3 | 5 | 7 | 3 | 11 | 5 |
| 2 | 3 | 5 | 2 | 7 | 3 | 11 | 5 |
```

# 19. 더블리 링크드 리스트 prepend 메소드

더블리 링크드 리스트에서 주어진 노드 뒤에 새로운 노드를 삽입하는 연산을 배웠는데요. 이 연산을 메소드로 구현했을 때는 **`insert_after`** 메소드로 구현했습니다.
사실 이 연산에는 한 가지 흠이 있는데요. 이 연산은 항상 주어진 노드 다음에 노드를 삽입하잖아요? 파라미터로 가장 앞 노드 head를 넘겨줘도 head 노드 앞에는 새로운 노드를 추가할 수 없습니다. 링크드 리스트 가장 앞에는 삽입할 수 없다는 거죠.
이 문제를 해결해주는 새로운 메소드를 정의해줍시다. 이 메소드는 **`prepend`**라고 부르고요, 파라미터로 데이터 **`data`**를 받아서 링크드 리스트의 가장 앞에 데이터를 **`data`**로 갖는 새로운 노드를 추가시켜줍니다.

- *주의: **`prepend`** 메소드를 작성할 때 링크드 리스트가 비어 있는 경우도 생각해서 작성하셔야 됩니다!

### **출력 예시**

```
| 2 | 3 | 5 | 7 | 11 |
2
11
```

### 초기 코드

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스
        
        
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
            self.head = None  # 링크드 리스트 가장 앞 노드
            self.tail = None  # 링크드 리스 가장 뒤 노드

    def prepend(self, data):
        """링크드 리스트 가장 앞에 데이터를 추가시켜주는 메소드"""
        # 코드를 쓰세요

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += " {} |".format(iterator.data)
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
    
    
# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
my_list.prepend(11)
my_list.prepend(7)
my_list.prepend(5)
my_list.prepend(3)
my_list.prepend(2)

print(my_list) # 링크드 리스트 출력

# head, tail 노드가 제대로 설정됐는지 확인
print(my_list.head.data)
print(my_list.tail.data)
```

## 해설

### **새로운 노드 만들기**

```python
    def prepend(self, data):
        """연결 리스트 가장 앞에 데이터를 추가시켜주는 메소드"""
        # 코드를 쓰세요.
        new_node = Node(data)  # 새로운 노드 생성
```

링크드 리스트에 새로운 데이터를 더해줄 때는 항상 그 데이터를 저장하는 새로운 노드를 만듭니다. 파라미터 **`data`**를 저장하는 노드를 만들고 변수 **`new_node`**에 저장해줄게요.

### **경우 1: 링크드 리스트가 비었을 때**

```python
        # head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node
```

그다음에는 링크드 리스트가 빈 경우를 생각해볼게요. 링크드 리스트가 비었는지 안 비었는지는 head 노드가 비었는지를 확인하면 알 수 있습니다. **`if self.head is None:`**을 쓰면 확인할 수 있죠.
이 경우에서는 **`append`** 메소드에서 했던 것과 똑같이 새로 만든 노드를 링크드 리스트의 처음이자 마지막 노드로 만들어줍니다.

### **경우 2: 링크드 리스트가 안 비었을 때**

```python
        # 이미 노드가 있으면
        else:
            new_node.next = self.head  # 새로운 노드의 다음 노드를 head 노드로 지정
            self.head.prev = new_node  # head 노드의 전 노드를 새로운 노드로 지정
            self.head = new_node  # head 노드 업데이트
```

그다음에는 링크드 리스트 안에 이미 데이터가 있는 경우를 처리합니다. 경우가 2 개밖에 없으니까 else 문을 사용합니다.
링크드 리스트 안에 이미 노드가 있을 때는 원래 head 노드 앞에 새로 만든 노드를 연결시켜주고, 새로 만든 노드를 링크드 리스트의 head 노드로 만들어주면 됩니다.
조금 더 구체적으로는:

1. head 노드를 새로운 노드의 다음 노드로 만들어주고
2. 새로운 노드를 head 노드의 전 노드로 만들어줍니다
3. 그리고 이제 새로운 노드가 링크드 리스트의 가장 앞 노드니까, 새로운 노드를 링크드 리스트의 head 노드로 설정해줍니다.

이 세 개를 해주면 되는 거죠.

### **해답 코드 정리**

```python
    def prepend(self, data):
        """연결 리스트 가장 앞에 데이터를 추가시켜주는 메소드"""
        # 코드를 쓰세요.
        new_node = Node(data) # 새로운 노드 생성

        # head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node

        # 이미 노드가 있으면
        else:
            new_node.next = self.head # 새로운 노드의 다음 노드를 head 노드로 지정
            self.head.prev = new_node # head 노드의 전 노드를 새로운 노드로 지정
            self.head = new_node # head 노드 업데이트
```

### **실행 코드**

```python
# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 여러 데이터를 링크드 리스트 앞에 추가
my_list.prepend(11)
my_list.prepend(7)
my_list.prepend(5)
my_list.prepend(3)
my_list.prepend(2)

print(my_list)  # 링크드 리스트 출력

# head, tail 노드가 제대로 설정됐는지 확인
print(my_list.head.data)
print(my_list.tail.data)
```

### **출력 내용**

```
| 2 | 3 | 5 | 7 | 11 |
2
11
```

# 20. 더블리 링크드 리스트 삭제 연산 개념

1. 지우려는 노드가 링크드 리스트의 마지막 남은 노드인 경우
헤드와 테일 노드가 동일한 경우이기다 한데 간단하게 헤드와 테일에 None을 주면 된다.
2. 헤드 노드를 지우려는 경우
지우려는 노드가 헤드인데 그 노드가 테일은 아닌 경우이다. 일단 링크드 리스트의 헤드를 헤드 노드의 다음 노드로 바꿔준다. 그리고 새로운 헤드의 전 노드를 None으로 지정해 준다.
3. 테일 노드를 지우는 경우
이 경우도 헤드 노드를 지우는 경우와 매우 비슷하다. 링크드 리스트의 테일을 원래 네일의 전 노드로 바꿔준다. 그리고 새로운 테일의 다음 노드를 None으로 지정해준다.
4. 두 노드 사이에 있는 노드를 삭제할 때
node_to_delete의 전 노드의 다음 노드가 node_to_delete의 다음 노드를 가리키게 한다. 그리고 node_to_delete의 다음 노드의 전 노드가 node_to_delete의 전 노드를 가리키게 한다.

# 21. ****더블리 링크드 리스트 삭제 연산 구현****

애니메이션으로만 본 더블리 링크드 리스트 삭제 연산을 코드로 작성해보세요.
삭제 연산 메소드 이름은 **`delete`**입니다. 파라미터로는 링크드 리스트에서 삭제하려는 노드 **`node_to_delete`**를 받습니다.
영상에서 봤듯이 더블리 링크드 리스트 삭제 연산은 경우가 네 개가 있습니다. 모든 경우를 잘 생각하면서 **`delete`** 메소드를 구현해보세요! 
*단, **`delete`** 메소드는 항상 삭제하는 노드의 데이터를 리턴합니다!

### **출력 예시**

```
| 2 | 3 | 5 | 7 |
| 2 | 3 | 7 |
2
| 3 | 7 |
| 3 |
|
```

### 초기 코드

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, data):
        self.data = data  # 실제 노드가 저장하는 데이터
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스
        
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def delete(self, node_to_delete):
        """더블리 링크드 리스트 삭제 연산 메소드"""
        # 코드를 쓰세요
        
    def find_node_at(self, index):
        """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정한다"""

        iterator = self.head # 링크드 리스트를 돌기 위해 필요한 노드 변수

        # index 번째 있는 노드로 간다
        for _ in range(index):
            iterator = iterator.next

        return iterator

    def append(self, data):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(data)  # 새로운 노드 생성

        # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 이미 노드가 있으면
        else:
            self.tail.next = new_node  # 마지막 노드의 다음 노드로 추가
            new_node.prev = self.tail
            self.tail = new_node  # 마지막 노드 업데이

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = "|"

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += " {} |".format(iterator.data)
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str

# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 새로운 노드 4개 추가
my_list.append(2)
my_list.append(3)
my_list.append(5)
my_list.append(7)

print(my_list)

# 두 노드 사이에 있는 노드 삭제
node_at_index_2 = my_list.find_node_at(2)
my_list.delete(node_at_index_2)
print(my_list)

# 가장 앞 노드 삭제
head_node = my_list.head
print(my_list.delete(head_node))
print(my_list)

# 가장 뒤 노드 삭제
tail_node = my_list.tail
my_list.delete(tail_node)
print(my_list)

# 마지막 노드 삭제
last_node  = my_list.head
my_list.delete(last_node)
print(my_list)
```

## 해설

### **경우 1: 링크드 리스트 마지막 남은 노드 삭제**

```python
        # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
        if node_to_delete is self.head and node_to_delete is self.tail:
            self.tail = None
            self.head = None
```

첫 번째 경우는 우는 삭제하는 노드가 링크드 리스트에 마지막 남은 노드인 경우입니다. 삭제하는 노드가 head 노드인 동시에 tail 노드인 경우를 확인해주면 됩니다.
head와 tail 노드 변수들이 None을 가리키게 합니다. 링크드 리스트에 맨 앞과 뒤 노드가 없으니까 더 이상 링크드 리스트에는 아무 노드도 없습니다. **`node_to_delete`**를 지운 거죠.

### **경우 2: 링크드 리스트 head 노드 삭제**

```python
        # 링크드 리스트 가장 앞 데이터 삭제할 때
        elif node_to_delete is self.head:
            self.head = self.head.next
            self.head.prev = None
```

다음 경우는 head 노드를 지우는 경우입니다.
if문 대신 elif를 써서 이 경우를 찾습니다. elif문을 써야 링크드 리스트의 마지막 남은 노드를 지우는 경우랑 구별해서 처리해줄 수 있죠. 그러니까 정확히는 head 노드를 삭제하는데 이게 링크드 리스트에 남은 마지막 노드를 지우는 경우는 아닌 경우를 찾을 수 있는 거죠.

1. 먼저 새로운 head 노드를 원래 head 노드의 다음 노드로 지정하고
2. 새로운 head 노드의 전 노드를 None으로 지정합니다

### **경우 3: 링크드 리스트 tail 노드 삭제**

```python
        # 링크드 리스트 가장 뒤 데이터 삭제할 떄
        elif node_to_delete is self.tail:
            self.tail = self.tail.prev
            self.tail.next = None
```

다음은 tail 노드를 지우는 경우를 생각해보세요. head 노드를 지울 때랑 거의 똑같이 해주면 됩니다. 이번에도 링크드 리스트의 마지막 남은 노드를 지우는 경우와 구별하기 위해서 elif 문을 사용합니다.

실제로 노드 레퍼런스를 바꿔주는 부분도 거의 똑같은데요.

1. 새로운 tail 노드를 원래 tail 노드 전 노드로 지정하고
2. 새로운 tail 노드의 다음 노드를 None으로 지정합니다.

### **경우 4: 두 노드 사이 노드 삭제**

```python
        # 두 노드 사이에 있는 데이터 삭제할 때
        else:
            node_to_delete.prev.next = node_to_delete.next
            node_to_delete.next.prev = node_to_delete.prev
```

드디어 마지막 경우입니다. 마지막 경우는 두 노드 사이에 있는 노드를 지우는 경우입니다. 그냥 이 경우는 다른 모든 경우가 아닌 경우니까 else문을 써서 처리해줍니다.

1. **`node_to_delete`**의 다음 노드를 **`node_to_delete`**의 전 노드의 다음 노드로 지정하고
2. **`node_to_delete`**의 전 노드를 **`node_to_delete`**의 다음 노드의 전 노드로 지정합니다

더 이상 링크드 리스트 안에서 **`node_to_delete`**에 접근할 수 없게 만들게 연결을 끊어버리는 거죠.

### **지우는 노드 데이터 리턴**

```python
        # 삭제하는 노드 데이터 리턴
        return node_to_delete.data
```

마지막으로는 **`node_to_delete`**가 저장하고 있는 데이터를 리턴합니다.

### **해답 코드 정리**

정리하면 이렇게 됩니다

```python
    def delete(self, node_to_delete):
        """더블리 링크드 리스트 삭제 연산 메소드"""

        # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
        if node_to_delete is self.head and node_to_delete is self.tail:
            self.tail = None
            self.head = None

        # 링크드 리스트 가장 앞 데이터 삭제할 때
        elif node_to_delete is self.head:
            self.head = self.head.next
            self.head.prev = None

        # 링크드 리스트 가장 뒤 데이터 삭제할 떄
        elif node_to_delete is self.tail:
            self.tail = self.tail.prev
            self.tail.next = None

        # 두 노드 사이에 있는 데이터 삭제할 때
        else:
            node_to_delete.prev.next = node_to_delete.next
            node_to_delete.next.prev = node_to_delete.prev

        # 삭제하는 노드 데이터 리턴
        return node_to_delete.data
```

### **실행 코드**

```python
# 새로운 링크드 리스트 생성
my_list = LinkedList()

# 새로운 노드 4개 추가
my_list.append(2)
my_list.append(3)
my_list.append(5)
my_list.append(7)

print(my_list)

# 두 노드 사이에 있는 노드 삭제
node_at_index_2 = my_list.find_node_at(2)
my_list.delete(node_at_index_2)
print(my_list)

# 가장 앞 노드 삭제
head_node = my_list.head
print(my_list.delete(head_node))
print(my_list)

# 가장 뒤 노드 삭제
tail_node = my_list.tail
my_list.delete(tail_node)
print(my_list)

# 마지막 노드 삭제
last_node  = my_list.head
my_list.delete(last_node)
print(my_list)
```

```
| 2 | 3 | 5 | 7 |
| 2 | 3 | 7 |
2
| 3 | 7 |
| 3 |
|
```

# ****22. 더블리 링크드 리스트 시간 복잡도****

## 더블리 링크드 리스트 연산 & 시간 복잡도

| --- | --- |

더블리 링크드 리스트에는 접근, 탐색, 삽입, 삭제 연산을 할 수 있습니다.

### 접근 & 탐색 연산

접근과 탐색 연산은 싱글리 링크드 리스트 접근과 탐색이랑 똑같이 한다고 했는데요. 그러니까 head 노드부터 하나씩 다음 노드로 가면서 원하는 위치에 있거나 데이터를 갖는 노드를 찾았습니다. 링크드 리스트의 길이가 n이라고 할 때, 최악의 경우, 걸리는 시간은 이 n에 비례하니까 접근과 탐색은 O(n)이 걸립니다.

### 삽입 & 삭제 연산

삽입 연산은 특정 노드가 주어졌을 때 그 다음 위치에 새로운 노드를 더해줬는데요. 그냥 앞과 뒤 노드의 래퍼런스 몇 개만 바꿔주면 됐었죠? 링크드 리스트의 길이와 상관없이 항상 일정하게 노드를 삽입할 수 있습니다. O(1)이죠.
삭제 연산은 파라미터로 지우려는 노드를 받아서 그 노드를 링크드 리스트에서 지웠습니다. 이때는 경우가 4개로 조금 많긴 했는데요. 모든 경우 다 그냥 래퍼런스 두 개만 바꿔주면 노드를 지울 수 있었죠. 삽입과 마찬가지로 항상 일정한 시간, O(1)이 걸립니다.

### 현실적인 시간 복잡도

싱글리 링크드 리스트와 마찬가지로 더블리 링크드 리스트의 삽입과 삭제 연산을 하기 위해서는 특정 노드가 필요합니다. 그 특정 노드를 접근 또는 탐색한 후에야 삽입과 삭제도 할 수 있다는 말인데요.
링크드 리스트 연산에 삽입과 삭제를 포함시키지 않는 건 좀 불공평한 분석입니다. 그래서 현실적으로 더블리 링크드 리스트 연산들은 아래 표만큼 걸립니다.

| --- | --- |

### 삽입 & 삭제 연산 특수 경우

링크드 리스트는 head와 tail 노드를 변수로 갖고 있어서 바로 접근할 수 있습니다. 이 특성을 이용하면 링크드 리스트의 가장 앞과 뒤에 삽입이나 삭제 연산을 할 때 좀 더 효율적으로 할 수 있습니다. **`append`**와 **`prepend`** 메소드를 떠올려 보세요. 파라미터를 안 받고 그냥 바로 head노드에 접근해서 양 끝에 새로운 데이터를 삽입할 수 있었습니다.
마찬가지로 더블리 링크드의 **`delete`** 메소드에 파라미터로 head나 tail노드를 가지고와서 넘겨주면 양 끝 데이터를 한번에 O(1)으로 삭제할 수 있습니다.

| --- | --- |

### 싱글리 vs 더블리 링크드 리스트 tail 노드 삭제

| --- | --- | --- |

싱글리 링크드 리스트의 삭제 연산은 지우려는 노드의 바로 전 위치의 노드를 파라미터로 받습니다. 그렇기 때문에 tail 노드를 지우기 위해서는 tail 노드 전 노드에 접근해서 이걸 파라미터로 넘겨줘야 됐는데요. 맨 뒤 노드 바로 이전 노드에 접근하는데  O(n)이 걸렸기 때문에 효율적으로 할 수 없었습니다.
아까 말했듯이, 더블리 링크드 리스트는 삭제 연산을 할 때 지우려는 노드 자체를 파라미터로 받습니다. tail 노드는 링크드 리스트의 속성으로 저장하고 있기 때문에 바로 가지고 와서 삭제 연산의 파라미터로 넘겨주면 효율적으로 tail 노드를 삭제할 수 있습니다. head 노드도 마찬가지로 한 번에 삭제할 수 있죠.
링크드 리스트를 사용해야 되는 상황에서 tail 노드를 많이 삭제해야 된다면 싱글리 링크드 리스트보다 더블리 링크드 리스트를 사용하는 게 더 효율적인 거죠.

# 23. 싱글리 vs 더블리 링크드 리스트

두 자료구조의 가장 기본적인 차이는 노드가 갖는 레퍼런스이다. 싱글리 링크드 리스트 노드는 다음 노드에 대한 레퍼런스만, 더블리 링크드 리스트 노드는 전 노드와 다음 노드에 대한 레퍼런스를 둘 다 저장한다.
그래서 노드를 접근하는 방법이 다르다. 싱글리는 다음 노드에만 접근할 수 있다. **특정 노드에서 앞에 있는 노드들에 접근할 수 없다!** 반면 더블리 링크드 리스트는 앞, 뒤 노두 모두 접근할 수 있다. 즉, 한 노드에서 앞에 있는 노드들 까지 접근하고 싶으면 더블리 링크드 리스트를 쓰는게 낫겠다.
추가적인 공간에 대해 알아보겠다. 추가적인 공간은 자료 구조가 사용하는 공간 중 실제 저장하려는 데이터를 제외한 다른 정보가 저장된 공간을 의미한다. 링크드 리스트 노드들은 다른 노드들에 대한 레퍼런스를 저장한다. 이 레퍼런스를 저장하는 공간을 추가적인 공간이라고 할 수 있다. 싱글리 링크드 리스트 노드는 실제 데이터와 다음 노드에 대한 레퍼런스를 저장한다. 링크드 리스트 안에 있는 노드가 n개일 때 총 n - 1개의 레퍼런스가 저장되어 있다. 즉, n에 비례하는 공간 O(n)의 추가적인 공간을 사용하는 것이다. 더블리 링크드 리스트 노드는 실제 데이터와 전 노드에 대한 레퍼런스, 다음 노드에 대한 레퍼런스를 저장한다. 총 n개의 노드가 있다면 저장된 레퍼런스는 이 n - 2 개이므로 n에 비례하는 공간 그러니까 O(n)의 추가적인 공간을 사용하는 것이다. 두 자료구조의 추가적인 공간 복잡도가 O(n)으로 동일하긴하나 실제로는 더블링 링크드 리스트가 2배 정도 크다. 
정말 공간을 효율적이게 사용하고 싶을 때는 싱글리 링크드 리스트를 사용하는게 조금 더 좋다.