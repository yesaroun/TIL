# 5. 해시 테이블

복습: No
블로그: No

# 1. key-value 데이터

순서가 아니라 이미 알고 있는 정보를 이용해서 저장한 정보를 검색할 수 있는 데이터 유형을 key-value라고 한다. 
하나의 key와 그 key에 해당하는 value를 합쳐서: key - value 쌍 이라고 표현한다.
하나의 key에는 하나의 value만 있어야 된다.

# 2. Direct Access Table

- 효율적으로 key-value 쌍을 저장하고 가져올 수 있다.
- 낭비하는 공간이 많다.

인덱스는 데이터에 순서에 해당하는 정보이다. 항상 0부터 배열의 크기 -1까지의 자연수였다. 
인덱스를 key로 생각하고 데이터를 저장하면 직관적이게 key-value쌍을 저장할 수 있다.
가장 큰 key를 마지막 인덱스로 갖는 배열을 만든다. 그리고 각각의 key에 맞는 배열에 인덱스에 저장하는 것이다. 
배열의 가장 큰 장점은 인덱스에 O(1)로 접근할 수 있다는 점인데 key(인덱스)를 이용한 value 접근또한 O(1)으로 접근할 수 있다. 
이런 식으로 배열 인덱스를 키로 이용해서 데이터를 저장하고 가지고 오는 방식을 Direct Access Table이라고 부른다.
Direct Access Table을 이용해서 O(1)으로 키-벨류 데이터에 접근하는 건 좋은데, 이렇게하면 자칫 공간을 너무 많이 낭비해버릴 수도 있다. 왜냐하면 사용하는 인덱스는 5개 뿐인데 가장 큰 key값이 940이라고 해서 크기가 940의 배열을 생성하면 나머지의 공간은 낭비하기 때문이다.

# 3. 해시 테이블 개념

시간과 공간을 둘 다 효율적으로 사용하는 자료구조이다.

### 해시 함수

- 특정 값을 원하는 범위의 자연수로 바꿔주는 함수

키가 아무리 커도 항상 원하는 범위 사이의 자연수로 바꿀 수 있다. 

## 해시 테이블

1. 고정된 크기의 배열을 만든다.
2. 해시 함수를 이용해서 key를 원하는 범위의 자연수로 바꾼다.
3. 해시 함수 결과 값 인덱스에 key-value 쌍을 저장한다.

이 해시 함수와 배열을 같이 사용하는 자료 구조이다. 키를 바로 인덱스로 사용하지 않고 해시함수에 넣어서 리턴된 값을 인덱스로 사용한다. 
먼저 원하는 크기의 배열을 만든다.
711: “kim” 이 키 벨류를 저장하고 싶으면 키인 711을 해시 함수에 넣는다. 이때 30이 리턴되었으면 배열의 인덱스 30에 키와 value를 저장한다. direct access table에서는 인덱스가 키 자체였기 때문에 인덱스에 밸류만 저장했는데 해시 테이블에서는 한 인덱스에 키와 벨류를 모두 저장해준다. 이렇게 하면 배열의 크기가 무한대로 크지 않아도 어떤 키-벨류 쌍도 배열에 저장할 수 있다. 
저장한 데이터를 가지고 올 때도 똑같이 하면 된다. key 711을 구하고 싶으면 해시 함수에 711을 넣는다. 그러면 30이 리턴되니까 배열 인덱스 30에 접근해서 value를 가지고 온다.

# 4. 해시 함수

이번에는 해시 함수에 대해서 조금 더 알아보고 해시 함수를 구현할 수 있는 가장 간단한 방법들을 알아보자.

```python
101호: 최지웅
204호: 강영훈
302호: 성태호
711호: 김현승
942호: 손동욱
```

먼저 주어진 key를 원하는 범위의 자연수로 바꿔서 리턴해주는 것 말고 다른 해시 함수의 조건들을 보겠다.

1. 한 해시 테이블의 해시 함수는 결정론적이어야 된다.
똑같은 key를 넣었을 때는 항상 똑같은 결과가 나와야 한다. 942를 해시 함수에 넣을 때 어쩔 때는 5가 나오고 어쩔 때는 10이 나오고 이러면 안 된다는 거다. 942를 넣으면 항상 똑같은 결과가 나와야 된다.
2. 결과 해시값이 치우치지 않고 고르게 나온다.
그러니까 해시 함수에 101, 204, 302, 711, 942나 아무 숫자를 넣었을 때 항상 40만 나오면 안 된다는 거다. 원하는 범위가 0 부터 100까지의 자연수면, 이 사이에 아무 두 숫자가 나올 확률이 최대한 비슷해야 된다.
3. 빨리 계산할 수 있어야 된다.
해시 테이블은 모든 연산을 할 때마다 해시 함수를 써야 되는데, 해시 함수가 비효율적이면 해시 테이블도 비효율적일 수밖에 없다.

## **나누기 방법**

가장 직관적이면서 쉬운 방법은 나누기 방식이다. 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 함수이다. 그러니까 저장해야 되는 키가 40, 120, 788, 2307이고 배열의 크기가 200이라고 하면 그냥 key를 200으로 나누어서 남는 나머지를 리턴하는거다. 40을 넣으면 40, 120은 120, 788 은 180, 2307은 107가 리턴된다

```python
def hash_function_remainder(key, array_size):
    """해시 테이블의 key를 나누기 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    return key % array_size

print(hash_function_remainder(40, 200))
print(hash_function_remainder(120, 200))
print(hash_function_remainder(788, 200))
print(hash_function_remainder(2307, 200))
```

```
40
120
188
107
```

어떤 키가 들어와도 0 ~ 원하는 정수 범위의 자연수로 바꿔줍니다.

## **곱셈 방법**

곱셈 방법은 나누기 방법보다는 조금 까다롭다.
이해를 돕기 위해 예시로 key가 200이고 사용하려는 배열 크기가 30이라고 할게요.

1. 먼저 0<*a*<1 인 아무 값 a를 정합니다. 일단 임의로 0.6666로 정할게요
2. 그다음에 이 a에 key를 곱합니다. 그러니까 0.666에 200을 곱하면 133.32이 되는데 이때 정수 부분은 버리고 소수 부분만 남깁니다. 0.32가 남습니다.
3. 마지막으로 남은 소수 부분에 배열의 크기를 곱해줍니다. 0.32 * 30 하면 9.6이 되죠. 이번엔 소수점 부분을 버리고 9만 남깁니다.

왜 이 방법이 원하는 범위의 자연수를 리턴할까요? a와 key를 곱한 값의 정수 부분을 버리면 그 결과 값은 0.xxxx 이런 식으로 0과 1 사이의 소수가 나올 수밖에 없겠죠? 0과 1 사이의 소수에 테이블의 크기를 곱해버리면, 다시 0과 테이블 크기 사이의 수가 나오죠. 그러니까 0.0001에 테이블 크기 30을 곱하면 0.003이 나오고 0.9999에 테이블 크기 30을 곱하면 29.997이 나오는데요. 항상 0보다 크거나 같고 테이블 크기인 30보다는 작은 숫자가 나옵니다. 그리고 여기서 소수점 뒷자리를 버리니까 원하는 범위의 자연수를 구할 수 있습니다.

```python
def hash_function_multiplication(key, array_size, a):
    """해시 테이블의 key를 곱셈 방법으로 0 ~ array_size - 1 범위의 자연수로 바꿔주는 함수"""
    temp = a * key # a와 key를 곱한다
    temp = temp - int(temp) # a와 key를 곱한 값의 소숫점 오른쪽 부분만 저장한다

    return int(array_size * temp) # temp와 배열 크기를 곱한 수의 자연수 부분만 리턴한다

print(hash_function_multiplication(40, 200, 0.61426212))
print(hash_function_multiplication(120, 200, 0.61426212))
print(hash_function_multiplication(788, 200, 0.61426212))
print(hash_function_multiplication(2307, 200, 0.61426212))
```

```
114
142
7
20
```

## **정리**

나누기 방법과 곱셈 방법은 해시 함수로 사용할 수 있는 가장 간단한 두 예시였는데요. 사실 key를 받아서 원하는 범위의 자연수를 리턴하면서:

1. 결정론적이어야 된다.
2. 원하는 범위의 자연수 하나하나가 리턴될 확률이 최대한 비슷해야 된다.
3. 빨리 계산을 할 수 있어야 된다.

이 세 조건을 만족하는 아무 함수나 만들면 해시 함수로 이용할 수 있습니다.

# 5. 파이썬 hash함수

## **파이썬 hash 함수**

파이썬 언어도 내부적으로 **`hash`**라는 함수를 제공한다. 근데 해시 함수랑 조금 다르다. 파이썬 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꿔주는 함수이다.
해시 함수와는 달리 특정 범위 안에 있는 정수가 아니라 **아무** 정수로 바꿔준다.
정수형, 소수형, 문자열 타입에 **`hash`** 함수를 호출했을 때 나오는 결과를 살펴보자.

```python
# 정수 값
print(hash(12345))  # 12345
print(hash(12345))  # 12345

# 다른 정수 값
print(hash(12346))  # 12346
```

```python
# 소수 값
print(hash(15.1234))  # 284541027336970255
print(hash(15.1234))  # 284541027336970255

# 다른 소수 값
print(hash(81.1234))  # 284541027336978513
```

```python
# 문자열
print(hash("파이썬"))  # -8002119629611903017
print(hash("파이썬"))  # -8002119629611903017

# 다른 문자열
print(hash("자바"))  # -8553573703343279427
```

이런식으로 같은 값을 넣으면 항상 같은 정수를 리턴해주는 함수이다. 이 때 중요한 점은 **`hash`** 함수에 서로 다른 두 값을 파라미터로 넣었을 때 같은 정수가 리턴될 수 없다는 건데요.
그러니까 **`hash("파이썬")`**이 **`-8002119629611903017`**이 리턴됐으면, 다른 그 어떤 값을 파라미터로 넣어도 **`-8002119629611903017`**가 나올 수 없습니다. 데이터를 자신만의 고유한 정수 값으로 바꿔주는 함수죠
지금까지는 해시 함수에 key를 정수형으로만 생각했잖아요? 다른 타입의 데이터들을 자신만의 고유한 정수 값으로 바꿀 수 있으면 이제 정수 뿐만 아니라 다른 자료형들도 key로 사용할 수 있습니다. 해시 테이블에 저장할 수 있는 종류의 데이터를 더 폭 넓게 늘릴 수 있다는 말이죠. 과제에서 해시 테이블을 직접 구현할 때 이 **`hash`** 함수를 사용해서 해시 테이블에 key가 문자열인 데이터를 저장할 건데요. 그 때 그냥 “아 문자열을 고유한 정수 값으로 바꿔주는구나”라고 이해하시면 됩니다!

# **hash 함수의 한계**

여기서 조심해야 되는 게 하나 있는데요. 파이썬 **`hash`** 함수는 언어 자체적으로는 불변 타입 자료형에만 사용할 수 있습니다.
파이썬에서 여러분이 가장 많이 접해봤을 대표적인 불변 타입 자료형은:

- 불린형
- 정수형
- 소수형
- 튜플
- 문자열

이 정도가 있는데요. 이런 타입의 자료형만 **`hash`** 함수의 파라미터로 넘겨줄 수 있습니다.

# 6. 해시 테이블 충돌과 Chaining개념

문제점이 있는데 key 101과 204 데이터를 저장하고 싶은데 둘을 해시 함수에 넣었을때 return값이 둘다 20이 나오는 경우 하나의 key에 두개의 value가 되는 경우가 된다. 이렇게 이미 사용하고 있는 인덱스에 새로운 key-value쌍을 또 저장해야 하는 경우에 **충돌(Collision)이 일어났다고** 표현한다. 해시 테이블을 사용하기 위해서는 충돌을 제대로 처래해야 한다.
이 충돌을 처리하는 한가지 방법이 Chaining(체이닝)이다.

## Chainig

직역을 하면 쇠사슬을 엮는다는 뜻이다. 말 그대로  충돌이 일어나면 그 값들을 쇠사슬처럼 엮겠다는 말이다. 여기서는 배열 인덱스에 링크드 리스트를 사용해서 체이닝을 해보겠다. 

# 7. Chaining에서 사용하는 링크드 리스트

전 레슨에서도 보았듯이 Chaining을 이용하면 해시 테이블에서 충돌이 일어나도 key - value 쌍들을 모두 저장할 수 있습니다. 
더블리 링크드 리스트를 이용하겠습니다.

## **Node 클래스**

링크드 리스트 노드가 변수 **`data`** 대신 **`key`**와 **`value`**를 저장하도록 해줄게요.

```python
class Node:
    """링크드 리스트의 노드 클래스"""
    def __init__(self, key, value):
            self.key = key
            self.value = value
            self.next = None    # 다음 노드에 대한 래퍼런스
            self.prev = None    # 전 노드에 대한 래퍼런스
```

## **LinkedList 클래스**

링크드 리스트 클래스에서는 필요한 메소드들만 가지고 와서 쓰면 됩니다. 노드 클래스랑 마찬가지로 그대로 사용할 수는 없고, 조금씩 고쳐서 써야합니다.
다행히 **`__init__`** 메소드는 바꾸지 않아도 됩니다.

```python
class LinkedList:
    """링크드 리스트 클래스"""
    def __init__(self):
        self.head = None        # 링크드 리스트의 가장 앞 노드
        self.tail = None        # 링크드 리스트의 가장 뒤 노드
```

### 탐색 메소드

```python
def find_node_with_key(self, key):
        """링크드 리스트에서 주어진 데이터를 갖고 있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다."""
        iterator = self.head    # 링크드 리스트를 돌기 위해 필요한 노드 변수

        while iterator is not None:
            if iterator.key == key:
                return iterator

            iterator = iterator.next

        return None
```

탐색 메소드는 이제 특정 데이터를 갖은 노드를 찾는 게 아니라 특정 key를 갖는 노드를 찾습니다. 이에 맞게 링크드 리스트를 처음부터 끝까지 돌면서 원하는 key를 갖는 노드를 리턴해주도록 수정해줍니다. 코드에서는 기존에 **`data`** 변수를 다 **`key`**로 바꿔주면 되죠.

### **추가 (맨 뒤 삽입) 메소드**

```python
def append(self, key, value):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(key, value)

        # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 이미 노드가 있으면
        else:
            self.tail.next = new_node   # tail의 다음 노드로 추가
            new_node.prev = self.tail
            self.tail = new_node        # tail 업데이트
```

추가 메소드 **`append`**는 이제 파라미터로 **`data`** 변수 대신 **`key`**와 **`value`**를 받습니다. 링크드 리스트에 데이터를 더해줄 때는 항상 새로운 노드를 만들어줘야 되는데요. 파라미터로 받은 정보를 key와 value를 갖는 새로운 노드를 만들어줍니다. 

### **삭제 메소드**

```python
def delete(self, node_to_delete):
        """더블리 링크드 리스트 삭제 연산 메소드"""

        # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
        if self.head is node_to_delete and self.tail is node_to_delete:
            self.tail = None
            self.head = None

        # 링크드 리스트 가장 앞 데이터 삭제할 때
        elif self.head is node_to_delete:
            self.head = self.head.next
            self.head.prev = None

        # 링크드 리스트 가장 뒤 데이터 삭제할 때
        elif self.tail is node_to_delete:
            self.tail = self.tail.prev
            self.tail.next = None

        # 두 노드 사이에 있는 데이터 삭제할 때
        else:
            node_to_delete.prev = node_to_delete.next
            node_to_delete.next = node_to_delete.prev
```

원래 링크드 리스트 삭제 메소드에서는 노드를 삭제할 때 삭제하는 노드의 데이터를 리턴했는데요. 이 부분을 빼줄게요.
나머지 부분은 바꿔줄 필요 없습니다. 더블리 링크드 리스트 삭제 메소드는 어차피 노드가 주어졌을 때 그 노드를 링크드 리스트에서 삭제해주죠? 기존 **`data`** 변수나 **`key`**, **`value`** 변수와 전혀 관계가 없는 메소드기 때문에 나머지 코드를 바꿀 필요가 없는 거죠.

### **문자열 메소드**

문자열 메소드는 출력 형식을 조금 바꿔줄게요.

```python
def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = ""

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트를 끝까지 돈다.
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += "{}: {}".format(iterator.key, iterator.value)
            iterator = iterator.next    # 다음 노드로 넘어간다.

        return res_str
```

원래는 링크드 리스트에 2, 3, 5, 7, 11이 들어있으면 이런 식으로 링크드 리스트의 모든 **`data`** 변수를 한 줄에 순서대로 출력했잖아요?

```
2 | 3 | 5 | 7 | 11
```

이제는 key - value 쌍을 저장하니까 출력 형식도 바꿔주는 거죠.
링크드 리스트에 **`101: “최지웅”`**, **`204: “강영훈”`**, **`305: “성태호”`**이 들어 있다고 할게요. 그러면 아래와 같이 이 링크드 리스트를 출력했을 때 한 줄에 한 key, value 쌍 하나씩 나오도록 바꿔준 거죠.

```
101: 최지웅
204: 강영훈
305: 성태호
```

# 8. Chaining을 쓰는 해시 테이블 탐색 연산

### 해시 테이블 탐색

- 원하는 key에 해당하는 value를 찾는 연산

해시 테이블은 데이터의 순서 관계를 저장하지 않기 때문에 접근 연산이 없고 대신 탐색 연산을 사용한다.
해시 테이블 탐색 연산은 주어진 키에 해당하는 value를 찾는다. 
키를 해시 함수에 넣고 해시 함수의 결괏값을 이용해서 배열의 인덱스에 접근한다. 인덱스에 저장된 링크드 리스트에 원하는 키가 저장되었는지 탐색한다. 링크드 리스트에서 원하는 데이터를 찾을 때는 가장 앞 노드부터 하나씩 보는 선형 탐색을 한다. 원하는 데이터를 찾으면 value를 return 한다.

### 탐색 연산 시간 복잡도 : O(n)

|  | 탐색 연산 각 단계들 |
| --- | --- |
| 해시 함수 계산 | O(1) |
| 배열 인덱스 접근 | O(1) |
| 링크드 리스트 탐색 | 링크드 리스트 길이 n일 때: O(n) |
| 총합 | O(n + 2) == O(n) |

해시 테이블에서 링크드 리스트 길이의 최악의 경우는 저장하는 모든 key-value 쌍이 한 링크드 리스트에 저장되는 경우이다. 총 n개의 key-value쌍을 저장하면 최악의 경우 한 링크드 리스트에 n개의 노드가 있는 것이다. 이때 링크드 리스트 탐색 시간은 O(n)이다. 

# 9. Chaining을 쓰는 해시 테이블 삽입 연산

### 해시 테이블 삽입

- key - value 데이터 쌍을 저장 또는 수정

먼저 키를 해시 함수에 넣는다. 해시 함수의 결괏값을 이용해서 배열의 인덱스에 접근한다. 그 다음에는 저장된 링크드 리스트에 원하는 키를 갖는 노드가 있는지 탐색한다. key-value쌍 데이터는 하나의 키에 대해서 하나의 벨류만 있다고 했다. 탐색을 안하고 바로 삽입하면 실수로 하나의 키에 여러 개의 key-value 쌍을 저장할 수도 있다. 그렇기 때문에 이미 삽입하려는 키가 있는지 없는지를 항상 확인해야 한다. 같은 키 노드를 찾으면 이 노드에 value를 새로운 value로 바꿔준다. 탐색에 실패하면 그냥 링크드 리스트 맽끝에 새로운 key-value를 추가한다.

### 삽입 연산 시간 복잡도

|  | 탐색 연산 각 단계들  |
| --- | --- |
| 해시 함수 계산 | O(1) |
| 배열 인덱스 접근 | O(1) |
| 링크드 리스트 노드 탐색 | O(n) |
| 링크드 리스트 저장 / 노드 수정 | O(1) |
| 총합 | O(1 + 1 + n + 1) == O(n) |

# 10. Chaining을 쓰는 해시 테이블 삭제 연산

### 해시 테이블 삭제

- 원하는 key에 대한 key - value 데이터 쌍을 삭제

삭제할 키를 해시 함수에 넣는다. 해시 함수의 결괏값을 이용해서 배열의 인덱스에 접근한다. 저장된 링크드 리스트의 원하는 키에 해당하는 노드를 탐색한다. 탐색 중 원하는 키를 갖고 있는 노드를 찾으면 링크드 리스트에서 지워준다. 

### 삭제 시간 복잡도

|  | 탐색 연산 각 단계들 |
| --- | --- |
| 해시 함수 계산 | O(1) |
| 배열 인덱스 접근 | O(1) |
| 링크드 리스트 노드 탐색 | O(n) |
| 링크드 리스트 노드 삭제 | O(1) |
| 총 합 | O(1 + 1 + n + 1) == O(n) |

# 11. (중요!) Chaining을 쓰는 해시 테이블 평균 시간 복잡도

| 동작(Operation) | 시간 복잡도 |
| --- | --- |
| 탐색(search) | O(n) |
| 저장(save) | O(n) |
| 삭제(delete) | O(n) |

해시 테이블의 탐색, 저장, 삭제 연산들은 이런 시간 복잡도를 갖는다. 세 연산 모두 key를 이용해서 저장된 링크드 리스트 노드를 탐색하는 과정을 포함한다. 링크드 리스트 탐색 연산은 링크드 리스트의 길이에 비례한다.
해시 테이블이 사용하는 링크드 리스트의 길이가 가장 길 경우는, 저장하는 모든 key-value 데이터 쌍이 하나의 링크드 리스트에 저장되는 경우이다. 해시 테이블에 저장된 key-value쌍의 수가 n이라고 하면 최악의 경우 링크드 리스트의 길이도 n인 것이다. 길이가 n인 링크드 리스트를 탐색하는 데 걸리는 시간은 O(n)이다. 세 연산 모두 링크드 리스트를 탐색하는 단계를 포함한다. 그렇기 때문에 세 연산은 최악의 경우 O(n)이 걸린다.
근데 해시 테이블의 모든 key-value 쌍이 모두 같은 링크드에 저장되는 건 거의 일어나지 않는 일일 텐데, 이걸 이용해서 해시 테이블의 연산들을 평가하는 건 좀 불공평하다.
동적 배열 추가 동작은 분할 상환 분석을 이용해서 조금 더 합리적으로 시간 복잡도를 구했었다. 이번에는 최악의 경우만으로 연산의 효율성을 평가하는게 불공평할 때 사용하는 방법 중 하나인 평균 시간 복잡도를 이용해서 해시 테이블 연산들을 분석해 보겠다.

## 해시 테이블 연산들 분해 분석

먼저 해시 테이블 연산들의 단계를 나눠서 보겠다.

| 연산(Operation) | 부분 단계들 | 각 부분 단계 시간 복잡도 |
| --- | --- | --- |
| 탐색(search) | 1. 해시 함수 계산
2. 배열 인덱스 접근
3. 링크드 리스트 탐색 | O(1 + 1 + n) |
| 저장(save) | 1. 해시 함수 계산
2. 배열 인덱스 접근
3. 링크드 리스트 탐색
4. 탐색한 노드 수정 or 링크드 리스트 앞에 노드 삽입 | O(1 + 1 + n + 1) |
| 삭제(delete) | 1. 해시 함수 계산
2. 배열 인덱스 접근
3. 링크드 리스트 탐색
4. 탐색한 노드 삭제 | O(1 + 1 + n + 1) |

각 연산의 단계들을 나눠서 보면, 링크드 리스트를 탐색하는 데 O(n)이 걸리고 나머지 부분 단계들은 다 O(1)이 걸리는 것을 알 수 있습니다.
그리고 링크드 리스트 탐색이 n에 비례하는 이유는 모든 데이터가 하나의 링크드 리스트에 저장된 경우 때문이다.
배열에 저장된 각 링크드 리스트의 길이가 평균적으로는 n이 아니라 다른 값, 예를 들어 average_length라는 값이라면 어떨까? 나머지 부분 연산들의 시간 복잡도가 O(1)밖에 걸리지 않기 때문에 세 연산 모두 링크드 리스트 탐색에 걸리는 시간, O(average_length)가 걸린다고 할 수 있다.
해시 테이블 연산의 시간복잡도는 평균적으로는 이 average_lenght에 비례하는 것이다.
이 노트에서는 인덱스에 저장되어 있는 링크드 리스트들의 평균 길이 average_lenght가 어떻게 되는지 알아 볼 것이다. 이 평균 길이를 이용해서 해시 테이블 연산들의 평균 시간 복잡도를 재평가해보겠다.

## 배열에 저장되어 있는 링크드 리스트들의 평균 길이

일단 일반적인 경우 우리가 어떤 값들의 평균을 어떻게 구하는지 되짚어 보겠다. 가장 대표적인 예시인 평균 성적을 구하는 방법을 보겠다. 
각 인덱스에 저장된 링크드 리스트들의 평균 길이를 구해보겠다.
총 들어 있는 key-value 쌍 수를 배열 인덱스 수로 나눠주면 된다.
그러니까 key-value 쌍은 10개, 그리고 해시 테이블이 사용하는 배열의 크기가 20이면, 10/20 이렇게 해서 사용되는 링크드 리스트의 길이는 평균적으로 0.5인 것이다.
좀 더 일반화해서 표현해보면

1. 해시 테이블에 총 들어가 있는 key-value 쌍의 수 : n
2. 해시 테이블이 사용하는 배열의 크기 : m

라고 하면, 링크드 리스트들의 평균 길이는 n/m이라고 할 수 있다.
앞에서 봤듯이, 해시 테이블의 세 연산의 시간 복잡도는 모두 링크드 리스트의 길이에 비례했다. 이 링크드 리스트의 길이가 최악의 경우 n 이어서 각 연산의 평균 시간 복잡도도 O(n)이었던 거다.
링크드 리스트들의 평균 길이가 n/m이면 각 연산들은 “평균적으로 O(n/m)가 걸린다”라고 표현할 수 있다.
여기서 중요한 한 가지 가정을 하는데, 해시 테이블을 만들 때 항상 충분히 여유롭게 총 저장하는 key-value 쌍 수와 해시 테이블이 사용하는 배열의 크기를 비슷하거나 작다고 가정을 한다.
그러니까 해시 테이블을 사용할 때는 항상 어느 정도까지는 n == m이렇게 유지 시켜준다는 양속을 하는 건데, 이 약속만 지켜주면, 해시 테이블 연산들이 O(n/m)이 걸리니까 n==m을 적용하면 다시 O(1)이라고 표현할 수 있다.

## 해시 테이블 평균 시간 복잡도 종합

| 연산(Operation) | 평균 시간 복잡도 |
| --- | --- |
| 탐색(search) | O(1) |
| 저장(insert) | O(1) |
| 삭제(delete) | O(1) |

해시 테이블 평균 시간 복잡도를 위 표처럼 나타낼 수 있는 거다. 실제로 해시 테이블을 사용할 때는 대부분의 경우 세 연산들이 그냥 O(1)이 걸린다고 가정하고 사용한다.
분할 상환 분석할 때와 마찬가지로 이 연산들의 최악의 경우 시간 복잡도가 O(n)인 것으 변하지 않는다. 생각해보면 모든 key-value 쌍이 하나의 인덱스에 저장되는 일이 일어나기 쉽지는 않지만 실제 일어날 수도 있는 일이므로 이런 혼란을 줄이기 위해서 좀 더 정확하게는 아래 처럼 표현한다.
**”해시 테이블 삽입, 삭제, 탐색 연산들은 최악의 경우 O(n)이 걸리지만, 평균적으로는 O(1)이 걸린다.”**

# 12. Chaining을 쓰는 해시 테이블 구현 1

이번 과제에서 사용하는 링크드 리스트 클래스는 전에 노트에서 해시 테이블에서 사용할 수 있게 바꿔놓은 더블리 링크드 리스크 클래스입니다. 혹시 링크드 리스트 코드에서 이해가 안 되시는 부분이 있다면 전 노트를 참고하세요!

탐색 연산은 **`look_up_value`**라는 이름의 메소드로 구현할게요. 파라미터로는 탐색하려는 key를 받습니다. 파라미터 key에 해당하는 value를 리턴합니다.
삽입 연산은 **`insert`**라는 이름의 메소드로 구현합시다. 파라미터로는 key와 value 데이터 쌍을 각각 받습니다. 파라미터로 받은 key - value 쌍을 해시 테이블 안에 저장합니다. 단 이미 key에 해당하는 key - value 데이터 쌍을 저장했다면, 그 데이터 쌍의 value만 새로운 value로 바꿔줍니다.
(두 메소드 모두 **`main.py`** 파일에서 작성하시면 됩니다!)
여러분들이 좀 더 수월하게 과제를 하실 수 있도록 미리 메소드 몇 개를 정의해놨는데요. 하나씩 살펴볼게요.

### **init 메소드**

```python
        def __init__(self, capacity):
            self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
            self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장
```

해시 테이블 클래스는 인스턴스 변수로 **`_capacity`**와 **`_table`**을 받습니다.

- **`_capacity`**는 해시 테이블(이 사용하는 배열)의 크기입니다. 해시 테이블 인스턴스를 만들 때 파라미터 **`capacity`**를 받아서 **`self._capacity`**에 저장합니다.
- **`_table`**은 해시 테이블에서 사용하는 파이썬 리스트입니다. 크기는 **`_capacity`** 이며 각 인덱스에는 비어 있는 링크드 리스트를 저장합니다. 저희는 배열 대신 파이썬 리스트를 이용해서 해시 테이블을 구현해볼게요.
- 두 인스턴스 변수는 외부에서 접근하면 안 된다는 걸 알리기 위해서 앞에 **`_`**를 붙입니다.

예를 들어

```python
test_scores = HashTable(50)
```

이렇게 해시 테이블 인스턴스를 만들었다고 할게요. 그럼

- 일단 **`self._capacity`**에는 50이 저장됩니다.
- 그리고 **`self._table`**이 만들어집니다. **`self._table`**은 0 ~ 49까지 인덱스를 갖는 파이썬 리스트가 생성됩니다. 각 인덱스에는 비어 있는 링크드 리스트가 저장됩니다.

### **해시 함수**

```python
        def _hash_function(self, key):
            """
            주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
            주의: key는 파이썬 불변 타입이여야 한다.
            """
            return hash(key) % self._capacity
```

메소드 **`_hash_function`**은 파라미터로 key를 받습니다. 파이썬 **`hash`** 함수는 불변 타입의 값을 고유 정수값으로 변환해 주는데요. 이 정수에 나누기 방법을 이용해서 저희 해시 테이블의 해시 함수로 이용합니다. 해시 테이블의 해시 함수도 외부에서 사용하지 말라는 표시로 앞에 **`_`**를 써줍니다.
**`self._capacity`** 가 50이라면 무조건 0 ~ 49 사이의 자연수가 리턴됩니다.

### **문자열 메소드**

```python
        def __str__(self):
            """해시 테이블 문자열 메소드"""
            res_str = ""

            for linked_list in self._table:
                res_str += str(linked_list)

            return res_str[:-1]
```

문자열 메소드는 **`self._table`**을 한 인덱스씩 돌면서 각 인덱스에 저장된 링크드 리스트의 데이터를 출력합니다. 해시 테이블 안에 저장된 모든 key, value 데이터 쌍을 출력할 수 있습니다.

### **출력 예시**

- 해시 테이블은 순서가 저장되지 않기 때문에 순서는 출력 예시와 다를 수 있습니다.

```
현승: 85태호: 90지웅: 99규식: 97신의: 88영훈: 90동욱: 87
85
90
90
현승: 10태호: 20지웅: 99규식: 97신의: 88영훈: 30동욱: 87
```

## 초기 코드

HDLL.py

```python
class Node:
    """링크드 리스트의 노드 클래스"""

    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None  # 다음 노드에 대한 레퍼런스
        self.prev = None  # 전 노드에 대한 레퍼런스

class LinkedList:
    """링크드 리스트 클래스"""

    def __init__(self):
        self.head = None  # 링크드 리스트의 가장 앞 노드
        self.tail = None  # 링크드 리스트의 가장 뒤 노드

    def find_node_with_key(self, key):
        """링크드 리스트에서 주어진 데이터를 갖고있는 노드를 리턴한다. 단, 해당 노드가 없으면 None을 리턴한다"""
        iterator = self.head  # 링크드 리스트를 돌기 위해 필요한 노드 변수

        while iterator is not None:
            if iterator.key == key:
                return iterator

            iterator = iterator.next

        return None

    def append(self, key, value):
        """링크드 리스트 추가 연산 메소드"""
        new_node = Node(key, value)

        # 빈 링크드 리스트라면 head와 tail을 새로 만든 노드로 지정
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        # 이미 노드가 있으면
        else:
            self.tail.next = new_node  # 마지막 노드의 다음 노드로 추가
            new_node.prev = self.tail
            self.tail = new_node  # 마지막 노드 업데이

    def delete(self, node_to_delete):
        """더블리 링크드 리스트 삭제 연산 메소드"""

        # 링크드 리스트에서 마지막 남은 데이터를 삭제할 때
        if node_to_delete is self.head and node_to_delete is self.tail:
            self.tail = None
            self.head = None

        # 링크드 리스트 가장 앞 데이터 삭제할 때
        elif node_to_delete is self.head:
            self.head = self.head.next
            self.head.prev = None

        # 링크드 리스트 가장 뒤 데이터 삭제할 떄
        elif node_to_delete is self.tail:
            self.tail = self.tail.prev
            self.tail.next = None

        # 두 노드 사이에 있는 데이터 삭제할 때
        else:
            node_to_delete.prev.next = node_to_delete.next
            node_to_delete.next.prev = node_to_delete.prev

        return node_to_delete.value

    def __str__(self):
        """링크드 리스트를 문자열로 표현해서 리턴하는 메소드"""
        res_str = ""

        # 링크드 리스트 안에 모든 노드를 돌기 위한 변수. 일단 가장 앞 노드로 정의한다.
        iterator = self.head

        # 링크드 리스트 끝까지 돈다
        while iterator is not None:
            # 각 노드의 데이터를 리턴하는 문자열에 더해준다
            res_str += "{}: {}\n".format(iterator.key, iterator.value)
            iterator = iterator.next  # 다음 노드로 넘어간다

        return res_str
```

main.py

```python
from HDLL  import LinkedList  # 해시 테이블에서 사용할 링크드 리스트 임포트

class HashTable:
    """해시 테이블 클래스"""

    def __init__(self, capacity):
        self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
        self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장

    def _hash_function(self, key):
        """
        주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
        주의: key는 파이썬 불변 타입이여야 한다.
        """
        return hash(key) % self._capacity

    def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        # 코드를 쓰세요

    def insert(self, key, value):
        """
        새로운 key - value 쌍을 삽입시켜주는 메소드
        이미 해당 key에 저장된 데이터가 있으면 해당 key에 해당하는 데이터를 바꿔준다
        """
        # 코드를 쓰세요

    def __str__(self):
        """해시 테이블 문자열 메소드"""
        res_str = ""

        for linked_list in self._table:
            res_str += str(linked_list)

        return res_str[:-1]

test_scores = HashTable(50)  # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

print(test_scores)

# key인 이름으로 특정 학생 시험 점수 검색
print(test_scores.look_up_value("현승"))
print(test_scores.look_up_value("태호"))
print(test_scores.look_up_value("영훈"))

# 학생들 시험 점수 수정
test_scores.insert("현승", 10)
test_scores.insert("태호", 20)
test_scores.insert("영훈", 30)

print(test_scores)
```

## 해설

본격적으로 각 연산들을 메소드로 구현해보기 전에 먼저 각 연산들에서 반복적으로 쓰는 코드를 메소드로 정의해줄게요. 자주 사용하는 코드를 묶어서 메소드로 정의하면 코드를 좀 더 깔끔하게 쓸 수 있습니다.

### **헬퍼 메소드 1: _get_linked_list_for_key**

```python
    def _get_linked_list_for_key(self, key):
        """주어진 key에 대응하는 인덱스에 저장된 링크드 리스트를 리턴하는 메소드"""
        hashed_index = self._hash_function(key)

        return self._table[hashed_index]
```

**`_get_linked_list_for_key`** 메소드는 파라미터로 **`key`**를 받아서 그 key에 해당하는 인덱스에 있는 링크드 리스트를 리턴합니다.
코드를 살펴보면 해시 함수에 key를 넣어서 나온 결과 값을 변수 **`hashed_index`**에 저장합니다.
그리고 내부적으로 배열로 사용하는 **`self._table`**의 **`hashed_index`** 인덱스에 있는 링크드 리스트를 리턴해줍니다.

### **헬퍼 메소드 2: _look_up_node**

```python
    def _look_up_node(self, key):
        """파라미터로 받은 key를 갖고 있는 노드를 리턴하는 메소드"""
        linked_list = self._get_linked_list_for_key(key)
        return linked_list.find_node_with_key(key)
```

**`_look_up_node`** 메소드는 파라미터로 **`key`**를 받아서 그 key를 가지고 있는 링크드 리스트 노드를 리턴합니다.
첫 번째 줄에서는 배열의 원하는 인덱스에 있는 링크드 리스트를 가지고옵니다.
두 번째 줄에서는 이 링크드 리스트 안에서 원하는 key를 갖고 있는 노드를 탐색해서 리턴합니다.

- **`find_node_with_key`** 메소드는 링크드 리스트안에 파라미터로 받은 key가 없으면 **`None`**을 리턴합니다.

### **탐색 연산: look_up_value 메소드**

```python
    def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        return self._look_up_node(key).value
```

**`look_up_value`** 메소드는 헬퍼 메소드만 써서 작성할 수 있습니다.
먼저, 찾으려는 key를 파라미터로 받습니다. **`_look_up_node`** 메소드를 이용해서 원하는 key에 해당하는 노드를 찾습니다. 이 노드의 **`value`** 변수를 리턴합니다.
이미 써놓은 헬퍼 메소드를 잘 이용하기만 하면 되니까 쉽죠?

### **삽입 연산: insert 메소드**

```python
    def insert(self, key, value):
        """
        새로운 key - value 쌍을 삽입시켜주는 메소드
        이미 해당 key에 저장된 데이터가 있으면 해당 key에 해당하는 데이터를 바꿔준다
        """
        existing_node = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

        if existing_node is not None:
            existing_node.value = value  # 이미 저장된 key면 데이터만 바꿔주고
        else:
            # 없는 key면 링크드 리스트에 새롭게 삽입시켜준다
            linked_list = self._get_linked_list_for_key(key)
            linked_list.append(key, value)
```

key - value 데이터는 하나의 key에 두 개의 value를 저장하면 안 되잖아요? 그래서 해시 테이블 삽입 연산에서는 이미 저장한 키인지 아닌지를 확인해야 합니다.
헬퍼 메소드 **`_look_up_node`** 메소드를 이용해서 파라미터 key를 갖고 있는 노드를 탐색합니다. 이미 원하는 key에 대한 key - value 쌍을 저장했으면 변수 **`existing_node`**에 노드가 저장되고, 아니면 **`None`** 이 저장되겠죠?
파라미터로 받은 key가 이미 저장한 데이터 쌍이라면, **`existing_node`**의 변수 value를 파라미터로 받은 **`value`**로 바꿔줍니다.
파라미터 key에 대한 데이터가 저장되어 있지 않다면:

1. 원하는 인덱스에 저장된 링크드 리스트를 받아옵니다.
2. 이 링크드 리스트에 새로운 key - value 쌍을 추가합니다.

# **해답 코드 정리**

```python
from HDLL import LinkedList

class HashTable:
    def __init__(self, capacity):
        self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
        self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장

    def _hash_function(self, key):
        """
        주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
        주의: key는 파이썬 불변 타입이여야 한다.
        """
        return hash(key) % self._capacity

    def _get_linked_list_for_key(self, key):
        """주어진 key에 대응하는 인덱스에 저장된 링크드 리스트를 리턴하는 메소드"""
        hashed_index = self._hash_function(key)

        return self._table[hashed_index]

    def _look_up_node(self, key):
        """파라미터로 받은 key를 갖고 있는 노드를 리턴하는 메소드"""
        linked_list = self._get_linked_list_for_key(key)
        return linked_list.find_node_with_key(key)

    def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        return self._look_up_node(key).value

    def insert(self, key, value):
        """
        새로운 key - 데이터 쌍을 삽입시켜주는 메소드
        이미 해당 key에 저장된 데이터가 있으면 해당 key에 대응하는 데이터를 바꿔준다
        """
        existing_node = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

        if existing_node is not None:
            existing_node.value = value  # 이미 저장된 key면 데이터만 바꿔주고
        else:
            # 없는 키면 새롭게 삽입시켜준다
            linked_list = self._get_linked_list_for_key(key)
            linked_list.append(key, value)

    def __str__(self):
        """해시 테이블 문자열 메소드"""
        res_str = ""

        for linked_list in self._table:
            res_str += str(linked_list)

        return res_str[:-1]
```

### **실행 코드**

```python
test_scores = HashTable(50) # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

print(test_scores)

# key인 이름으로 특정 학생 시험 점수 검색
print(test_scores.look_up_value("현승"))
print(test_scores.look_up_value("태호"))
print(test_scores.look_up_value("영훈"))

# 학생들 시험 점수 수정
test_scores.insert("현승", 10)
test_scores.insert("태호", 20)
test_scores.insert("영훈", 30)

print(test_scores)
```

### **출력 예시**

```
현승: 85
태호: 90
지웅: 99
규식: 97
신의: 88
영훈: 90
동욱: 87
85
90
90
현승: 10
태호: 20
지웅: 99
규식: 97
신의: 88
영훈: 30
동욱: 87

```

# ****13. Chaining을 쓰는 해시 테이블 구현 II****

Chaining을 이용하는 해시 테이블 삭제 연산을 구현해볼게요.
삭제 연산의 메소드 이름은 **`delete_by_key`**입니다. 파라미터로 **`key`**를 받는데요. 해시 테이블에서 key에 해당하는 key - value 쌍을 지워줍니다.

- 저번 과제 해설에 나온 헬퍼 메소드를 사용하시면 조금 더 편하게 과제를 풀 수 있습니다.

### **출력 예시**

```
영훈: 90
동욱: 87
```

## 코드

HDLL.py(앞에 그대로)

main.py

```python
from HDLL import LinkedList  # 해시 테이블에서 사용할 링크드 리스트 임포트

class HashTable:
    def __init__(self, capacity):
        self._capacity = capacity  # 파이썬 리스트 수용 크기 저장
        self._table = [LinkedList() for _ in range(self._capacity)]  # 파이썬 리스트 인덱스에 반 링크드 리스트 저장

    def _hash_function(self, key):
        """
        주어진 key에 나누기 방법을 사용해서 해시된 값을 리턴하는 메소드
        주의: key는 파이썬 불변 타입이여야 한다.
        """
        return hash(key) % self._capacity

    def _get_linked_list_for_key(self, key):
        """주어진 key에 대응하는 인덱스에 저장된 링크드 리스트를 리턴하는 메소드"""
        hashed_index = self._hash_function(key)

        return self._table[hashed_index]

    def _look_up_node(self, key):
        """파라미터로 받은 key를 갖고 있는 노드를 리턴하는 메소드"""
        linked_list = self._get_linked_list_for_key(key)
        return linked_list.find_node_with_key(key)

    def look_up_value(self, key):
        """
        주어진 key에 해당하는 데이터를 리턴하는 메소드
        """
        return self._look_up_node(key).value

    def insert(self, key, value):
        """
        새로운 key - value 쌍을 삽입시켜주는 메소드
        이미 해당 key에 저장된 데이터가 있으면 해당 key에 해당하는 데이터를 바꿔준다
        """
        existing_node = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

        if existing_node is not None:
            existing_node.value = value  # 이미 저장된 key면 데이터만 바꿔주고
        else:
            # 없는 key면 링크드 리스트에 새롭게 삽입시켜준다
            linked_list = self._get_linked_list_for_key(key)
            linked_list.append(key, value)

    def delete_by_key(self, key):
        """주어진 key에 해당하는 key - value 쌍을 삭제하는 메소드"""
        # 코드를 쓰세요

    def __str__(self):
        """해시 테이블 문자열 메소드"""
        res_str = ""

        for linked_list in self._table:
            res_str += str(linked_list)

        return res_str[:-1]
    
 

test_scores = HashTable(50) # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

# 학생들 시험 점수 삭제
test_scores.delete_by_key("태호")
test_scores.delete_by_key("지웅")
test_scores.delete_by_key("신의")
test_scores.delete_by_key("현승")
test_scores.delete_by_key("규식")

print(test_scores)
```

## 해설

### **delete_by_key 메소드**

```python
    def delete_by_key(self, key):
        """주어진 key에 해당하는 key - value 쌍을 삭제하는 메소드"""
        node_to_delete = self._look_up_node(key)  # 이미 저장된 key인지 확인한다

        # 저장되어 있는 key면 삭제한다
        if node_to_delete is not None:
            linked_list = self._get_linked_list_for_key(key)
            linked_list.delete(node_to_delete)
```

**`delete_by_key`** 메소드는 파라미터로 **`key`**를 받아서 해시 테이블에서 그 key에 대한 key - value 쌍을 지워줍니다.
**`delete_by_key`**에서도 저번 과제 때 작성했던 헬퍼 메소드들을 사용하면 됩니다.
먼저 파라미터 **`key`**를 갖고 있는 노드를 받아옵니다. 이 노드를 **`node_to_delete`** 변수에 저장해줍니다.
만약에 지우려는 key를 갖고 있는 노드가 없다면 **`node_to_delete`** 가 **`None`**이겠죠?
반대로 **`None`**이 아니라는 것은 해시 테이블 안에 해당 key에 대한 key - value 쌍이 있다는 말입니다. 있을 경우 해시 값 인덱스에 저장된 링크드 리스트를 받아옵니다. 이 링크드 리스트에서 **`node_to_delete`**를 삭제해줍니다. 어짜피 링크드 리스트 클래스의 **`delete`** 메소드는 지우려는 노드 자체를 받잖아요. **`delete`** 메소드에 **`node_to_delete`** 변수를 파라미터로 넘겨줘서 링크드 리스트에서 삭제합니다.

### **실행 코드**

제대로 돌아가는지 코드를 돌려봅시다.

```python
test_scores = HashTable(50) # 시험 점수를 담을 해시 테이블 인스턴스 생성

# 여러 학생들 이름과 시험 점수 삽입
test_scores.insert("현승", 85)
test_scores.insert("영훈", 90)
test_scores.insert("동욱", 87)
test_scores.insert("지웅", 99)
test_scores.insert("신의", 88)
test_scores.insert("규식", 97)
test_scores.insert("태호", 90)

print(test_scores)

# 학생들 시험 점수 삭제
test_scores.delete_by_key("태호")
test_scores.delete_by_key("지웅")
test_scores.delete_by_key("신의")
test_scores.delete_by_key("현승")
test_scores.delete_by_key("규식")

print(test_scores)
```

### **출력 예시**

```
영훈: 90
동욱: 87
```

# 14. Open Addressing을 이용한 충돌 해결

해시 테이블의 충돌은 여러개의 키-벨류쌍을 같은 인덱스에 저장해야 되는 경우이다. 지금까지는 체이닝을 통해서 충돌을 해결하는 방법을 배웠다. 
이번에는 open addressing을 통해서 충돌을 해결하는 방법을 보겠다.
Open Addressing은 충돌이 일어났을 때 다른 비어 있는 인덱스를 찾아서 거기에 데이터를 저장하는 방법이다. 
비어 있는 인덱스를 찾는 방법중 이번 레슨에서는 가장 기본적인 방법인 선형 탐사(linear probing)에 대해서 알아보겠다. 

선형 탐사(linear probing)

- 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 확인

즉 충돌이 일어났을 때 빈 인덱스를 하나씩 순서대로 선형적으로 찾는 방법이다. 

# 15. Open Addressing 제곱 탐사

Open addressing을 했을 때 빈 인덱스를 찾는 가장 기본적인 방법인 선형 탐사, 영어로 Linear probing에 대해서 배워봤는데요. Open addressing을 사용한다고 해서 꼭 선형 탐사를 사용해야 되는 건 아닙니다.
이번 노트에서는 다른 방법 중 하나인 제곱 탐사(Quadratic Probing)에 대해서 알아볼게요.

## **제곱 탐사**

Open addressing을 이용하는 해시 테이블이 있다고 할게요. 하얀 색으로 체워져 있는 칸들이 key - value 쌍들이 저장된 인덱스들이고, 검은 칸들이 비어 있는 인덱스라고 할게요.

[https://bakey-api.codeit.kr/files/2235/R1bgUR?name=1.png](https://bakey-api.codeit.kr/files/2235/R1bgUR?name=1.png)

특정 값을 저장하려고 하는데 해시 함수의 결과가 10이 나왔다고 합시다. 인덱스 10에는 이미 데이터가 저장됐습니다.
선형 탐사를 이용했을 때는 인덱스 11을 확인하고, 인덱스 11은 차 있으니까 인덱스 12를 확인하고 이런 식으로 해서 빈 인덱스를 찾았는데요. 제곱 탐사는 처음에 1의 제곱 뒤에 있는 인덱스를 확인합니다.
1의 제곱은 1이니까 인덱스 11을 확인합니다. 인덱스 11은 차 있습니다.
그다음에는 인덱스 11에서 2의 제곱 뒤에 있는 인덱스를 확인합니다. 2의 제곱은 4입니다. 인덱스 15를 확인합니다. 인덱스 15도 차 있습니다.
그다음은 인덱스 15에서 3의 제곱 밑에 있는 인덱스를 확인합니다. 인덱스 24입니다. 인덱스 24는 비어 있습니다. 여기에 새로운 key - value 쌍 데이터를 저장합니다.
제곱 탐사는 이런 방식으로 선형적으로 바로 다음 인덱스들을 하나씩 확인하지 않고, 제곱을 한 값들을 이용해서 인덱스를 찾습니다.

# 16. Open Addressing 탐색/삭제 연산

## 탐색

선형 탐사를 이용해서 데이터를 찾으면 된다. 다만, 선형 탐사를 하다가 비어 있는 경우는 찾는 데이터가 처음부터 저장되지 않았다는 뜻이다. 

## 삭제

탐색 연산과 똑같이 키를 해시 함수에 넣는다. 결과값을 배열 인덱스로 사용해서 접근한다. 이후에는 선형탐사를 한다. 데이터 쌍을 찾았다고 단순하게 삭제를 하면 안된다. 다른 데이터를 탐색할때 문제가 생길 수도 있기 때문이다. 그래서 삭제한 인덱스를 빈값으로 두지 않고 “DELETE” 혹은 다른 약속된 표시를 해준다. 

# ****17. Open Addressing을 쓰는 해시 테이블 시간 복잡도****

Open Addressing을 사용하는 해시 테이블은 각각 탐색, 삽입, 삭제 연산들을 얼마나 효율적이게 하는지 알아봅시다.

### **연산들의 세부 단계들**

Chaining과 마찬가지로 key를 해시 함수에 넣어서 삽입하고, 이 결과 값을 이용해서 인덱스에 접근하는 데 걸리는 시간은 O(1)입니다. 원하는 인덱스에 key - value 쌍을 저장하는 것도 마찬가지로 O(1)이죠.
Open Addressing을 하게 되면 탐색, 삽입, 삭제 연산들 모두 인덱스를 찾는 탐사를 해야 합니다. 정확히 얘기하면 삽입 연산은 탐사를 통해서 빈 인덱스를 찾고, 탐색과 삭제 연산은 원하는 key를 갖는 데이터 쌍을 찾습니다. 탐사를 할 때 걸리는 시간을 알아볼게요.

### **탐사 최악의 경우**

최악의 경우를 생각해봅시다. 어떤 경우에 가장 탐사를 많이 해야 될까요?
해시 테이블이 사용하는 배열이 거의 꽉 찼을 때인데요. 예를 들어서 그림처럼 사용하는 배열이 인덱스 13 말고 모두 찼다고 생각해봅시다.

[https://bakey-api.codeit.kr/files/2237/GlmNCq?name=1.png](https://bakey-api.codeit.kr/files/2237/GlmNCq?name=1.png)

여기에 새로운 key - value 쌍을 저장하고 싶으면 어떻게 할까요? key를 해시 함수에 넣었을 때 14가 리턴됐다고 할게요. 그럼 인덱스 14에서 선형 탐사를 이용해서 빈 인덱스를 찾아야 되는데요. 14, 15, 16… 이렇게 쭉 탐사를 하다가 마지막에 인덱스 13을 찾겠죠?
그러니까 빈 인덱스를 찾기 위해 배열 안에 있는 모든 인덱스를 하나씩 다 확인해야 합니다. 해시 테이블 안에 저장된 key - value 쌍의 개수가 n일 때, n에 비례하는 시간이 걸리는 거죠.
그럼 위에서 삽입한 인덱스 13에 저장한 데이터를 탐색하거나 삭제하고 싶을 때는 어떻게 할까요? key를 해시 함수에 넣으면 아까랑 똑같이 14가 나올탠데요. 다시 선형 탐사로 배열의 모든 인덱스를 다 돌아야 됩니다.
이때도 마찬가지로 n에 비례하는 시간이 걸리는 거죠.
탐사를 제외한 세 연산의 다른 모든 단계들은 O(1)이 걸렸는데요. 탐사는 최악의 경우 O(n)이 걸립니다. 세 연산 모두 탐사가 포함되기 때문에 아래 표에 나와 있는 거만큼 시간이 걸린다고 할 수 있습니다.

## **Open Addressing 연산 시간 복잡도**

| 연산 | 시간 복잡도 (최악의 경우) |
| --- | --- |
| 삽입 | O(n) |
| 탐색 | O(n) |
| 삭제 | O(n) |

# ****18. (중요!) Open Addressing을 쓰는 해시 테이블 평균 시간 복잡도****

저번 레슨에서는 해시 테이블의 연산들을 최악의 경우를 이용해서 분석해봤습니다. 최악의 경우는 해시 테이블이 사용하는 배열이 거의 꽉 찼을 경우였잖아요? 근데 생각해보면 해시 테이블이 거의 꽉 차 있는 경우는 잘 일어나지 않고, 대부분 경우는 여유 공간이 넉넉하게 있을 탠데요.
Chaining을 이용하는 해시 테이블과 마찬가지로 이 세 연산들을 모두 최악의 경우로만 분석하면 좀 불공평합니다.
Open Addressing을 사용하는 해시 테이블의 연산들도 평균 시간 복잡도로 표현해 볼게요.

## **load factor**

해시 테이블 연산들을 분석할 때는 load factor라는 것을 사용합니다. load factor *α*는 해시 테이블이 사용하는 배열의 크기를 m, 해시 테이블 안에 들어 있는 데이터 쌍 수를 n이라고 할 때:
*α* = n/m
인데요. 그냥 해시 테이블이 얼마나 차있는지를 나타내는 변수입니다.
Open addressing을 할 때 해시 테이블의 연산들을 분석할 때는 load factor는 굉장히 중요한 역할을 합니다. 해시 테이블 안에 배열의 크기보다 많은 key - value 쌍을 저장할 수 없기 때문에 load factor *α*는 항상 1보다 작다고 가정합니다.

### **결과**

결과적으로 얘기하면 Open addressing을 사용하는 해시 테이블에서 평균적으로 탐사를 해야 되는 횟수 (기댓값)은 1/(1−*α)*보다 작습니다.
기댓값이 1/(1−*α)*라는 걸 무슨 의미일까요? 배열이 총 100 칸이라고 하고 90 개의 key - value 쌍을 저장했다고 합시다. 그럼 load factor *α*=0.9 인 건데요.
기댓값에 *α*를 대입하면 10이 나옵니다. 그러니까 빈 인덱스를 찾기 위해서 평균적으로 인덱스 10 개보다 적은 인덱스를 확인해도 된다는 뜻이죠. 사실 load factor 가 0.9도 굉장히 load factor가 큰 거고요. 만약에 *α*=0.5 그러니까 해시 테이블이 반 정도 차있다면 어떨까요? 기댓값은 2보다 작습니다. 그러니까 해시 테이블이 반이나 차 있어도 평균적으로 두 개의 인덱스만 확인해봐도 빈칸을 찾을 수 있다는 거죠.
그럼 해시 테이블을 사용할 때, 항상 load factor가 0.9가 넘지 않게 사용하겠다고 약속을 하면 어떻게 될까요? (일반적으로 이 제한을 변수 c를 사용해서 표현합니다)1/(1−*α)*를 계산해보면 평균적으로 10 보다 적게 탐사를 해야된다고 할 수 있는데요. 0<*alpha*<0.9 일 때는 평균적으로 항상 10보다 적게 탐사할 수 있겠죠? 그렇기 때문에 이 가정을 한다면,성공적으로 원하는 인덱스를 찾는데 봐야 하는 인덱스 수는 평균적으로 *O*(10) 이하, 즉 *O*(1)이라고 할 수 있습니다. 탐사가 평균적으로 *O*(1)이 걸리는 거죠.
Open addressing을 사용한 해시 테이블 연산들의 시간 복잡도가 *O*(*n*)인 이유는 다른 단계들은 *O*(1)으로 할 수 있는데 탐사가 최악의 경우 *O*(*n*)이 걸리기 때문이었는데요. 방금 봤듯이 탐사는 최악의 경우 *O*(*n*)이 걸리지만 평균적으로는 *O*(1)의 시간이 걸립니다.
그러니까 Open addressing을 사용하든 Chaining을 사용하든 해시 테이블의 모든 연산들을 평균적으로 *O*(1)로 할 수 있는데요? 굉장히 효율적이죠.

| 연산 | 시간 복잡도 (평균) |
| --- | --- |
| 삽입 | O(1) |
| 탐색 | O(1) |
| 삭제 | O(1) |

## **수학적 분석**

여기서부터 어떻게 해서 탐사 연산의 기대 시간이 1/(1−*α)* 보다 작은지를 수학적으로 분석해보겠습니다. 굳이 보기 싫으신 분들은 건너 뛰셔도 상관없습니다. 또 수학적인 내용이 굉장히 많이 있는데요. 수학적인 부분들이 이해가 안 되시는 부분이 있으시면 이 레슨 질문들을 참고하시거나 새롭게 질문을 해주시면 답해드리겠습니다.

먼저 해시 테이블 배열 크기가 10이라고 하고 여기에 4 개의 key - value 쌍을 저장했다고 가정합시다.
그리고 여기서 새로운 key - value 쌍을 삽입하고 싶다고 할게요.
처음 해시 함수를 계산해서 나온 결과 값 인덱스가 이미 차있을 확률을 얼마나 될까요?

- 총 10칸 중 4칸은 차있고 6칸은 비어 있잖아요? 아무 인덱스나 골랐을 때 차있을 확률은 4/10 가 되겠죠?

이 인덱스가 차있으면 탐사로 비어 있는 다른 인덱스를 찾아야 되는데요. 그럼 이 인덱스도 차 있을 확률은 어떻게 될까요? 그러니까 첫 번째로 확인한 인덱스도 차있고 두 번째 확인한 인덱스도 차있는 경우인데요.

- 첫 번째 인덱스가 이미 차 있으니까 이제 탐사를 아직 안 한 9 개 칸 중 3 개만 차있을 텐데요. 그럼 또 다른 인덱스가 차있을 확률은 9개 중 3개니까 3/9 입니다.
- 그리고 첫 번째와 두 번째 탐사 인덱스가 모두 찼을 확률은 4/10 * (4-1)/(10-1) 이렇게 되는 거죠

다음 칸도 차 있을 확률도 계산해 봅시다

- 이제 8 개 칸 중 2 개만 차있습니다. 8 개 중 2 개니까 2/8입니다.
- 탐사를 할 때 첫 세 인덱스가 모두 찼을 확률은 4/10 * (4-1)/(10-1) * (4-2)/(10-2) 입니다.

패턴이 보이기 시작하시나요?
빈 인덱스를 탐사할 때 i 번 이상 탐사를 해야될 확률을 *Pi* 라고 할게요. i 번 이상 탐사를 해야된다는 말은, 첫 번째 인덱스부터 i-1 인덱스까지가 차있다는 말이잖아요? 그렇기 때문에 이렇게 표현할 수 있습니다:

*Pi = n/m * (n-1)/(m-1) * (n-2)/(m-2) * (n-i+2)/(m-i+2)*

그럼 이렇게도 표현할 수 있습니다.

*Pi = n/m * (n-1)/(m-1) * (n-2)/(m-2) * (n-i+2)/(m-i+2) < (n/m)^(i-1)*

수학식이 좀 복잡하긴 한데요. 아까 예시를 이용해서 설명하자면 다시 보면 크기가 10인 배열에서 4 번 이상 탐색을 해야될 확률 *P*4 (첫 번째부터 3 번째 인덱스까지 모두 차있을 확률)는:

*P*4 = 4/10 * 3/9 * 2/8 < 4/10 * 4/10 * 4/10 라는 뜻인데요.

왼쪽 항이 항상 오른쪽 항보다 작죠? 위에 저 복잡한 식이 그냥 이런 관계를 나타낸 겁니다. 왼쪽 항이 *Pi*니까

*Pi* < (n/m)^(*i*−1) 라고 할 수 있습니다.

그리고 n/m = *α* 니까

*Pi* < *α^(i*−1) 라고 할 수 있죠.

*Pi*는 탐사를 i 번 이상할 확률이잖아요? 이 확률을 이용하면 평균적으로 몇 번의 탐사를 해야 빈 인덱스를 찾을 수 있는지를 계산할 수 있는데요. 이걸 기댓값이라고 합니다.
기댓값을 *Ex*라고 하면, 지금 같은 경우는 기댓값을 이렇게:
*Ex*=*P*1+*P*2+*P*3+...
계산할 수 있습니다(이 부분이 이해가 안 되시면 레슨 질문에 설명드리니 참고해주세요!). *Pi*<*α^(i*−) 이니까
*Ex*<1+*α*+*α^2*+*α^3*...  라고 할 수 있고 *α*<1이기 때문에 등비 수열이란 건데요.  이걸 정리하면:
*Ex*<1/(1−*α)* 라고 할 수 있습니다.
따라서, 평균적으로 탐사를 해야되는 값의 기댓값은 1/(1−*α)* 보다 작다고 할 수 있습니다.