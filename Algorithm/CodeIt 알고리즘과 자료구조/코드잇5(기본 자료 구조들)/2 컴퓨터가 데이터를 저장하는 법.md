

# 1. 스토리지 vs 메모리

데이터가 저장되는 곳은 스토리지(Storage)와 메모리(Memory)이다.

## 스토리지

데이터가 영구적으로 저장되는 곳(사진, 문서, 음악 등), 스토리지의 데이터는 사용자가 지우거나 심각한 외부 충격이 있지 않는한 사라지지 않는다.
다만 데이터를 저장하고 받아오는데 오래 걸린다.
즉, 정확히 언제 사용할지 모르겠는 파일들을 저장한다.

## 메모리

데이터가 임시로 저장되는 곳
데이터를 저장하고 받아오는데 빠르다

# 2. RAM: Random Access Memory

![[2_1.png]]

메모리를 비유하자면 길다란 띠라고 할 수 있다.  이 띠는 **일정한 칸으로 나눠져 있고 각 칸에는 데이터를 저장**할 수 있다. 그리고 데이터를 찾을 수 있겠끔 **각 칸에는 자신만의 주소가 있다**. 

## RAM : 임의 접근 메모리

컴퓨터의 메모리를 ram이라고도 하는데 임의 접근은 저장 위치를 알면 접근할 때 항상 일정한 시간의 걸리는 것을 말한다. 메모리의 각 칸에 있는 주소가 있는데 그 주소와 상관없이 원하는 값을 한번에 찾을 수 있다는 것이다. 어디에 있는 걸리는 시간은 똑같으니 시간 복잡도로 이야기하면 O(1)이다.
메모리에 저장한 데이터 접근 시간 복잡도 : O(1)

cf) 
순차 접근 : 저장된 위치까지 가는데 한 단계씩 거쳐야 한다.
즉, 임의 접근이 순차 접근보다 효율적이다!

# 3. 메모리의 기본 단위: 바이트

![[2_1.png]]

메모리는 하나의 긴 띠라고도 표현했는데요. 이 띠는

1. 일정한 칸으로 나눠져 있고
2. 각 칸에 데이터를 저장할 수 있고
3. 각 칸은 자신만의 주소가 있습니다

이 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 **바이트**, 영어로는 **byte**입니다. 자료 구조를 공부하면서 바이트라는 단위가 정확히 얼만큼의 정보를 저장하는 단위인지는 모르셔도 됩니다. 그냥 엄청 작은 단위라고만 알고 계시면 됩니다.
바이트가 아닌 다른 크기의 용량을 담는 저장 장치들도 있긴 한데요. 대부분의 현대 컴퓨터 시스템들은 메모리 한 칸에 바이트만큼의 데이터를 저장합니다.
일상 생활 속에서도 많은 분들께서 이미 바이트라는 용어를 들어보셨을 텐데요. 흔히 영상, 문서, 음성 파일이나, RAM 또는 컴퓨터의 스토리지의 크기를 표현할 때,

- 160 킬로 바이트(kB)
- 10 메가 바이트(MB)
- 32 기가 바이트(GB)

이런 식으로 많이 표현하는데요. 킬로 바이트, 메가 바이트, 기가 바이트는 그냥 데이터의 용량이 몇 바이트인지 표현한 겁니다. 정확히 얘기하자면,

- 킬로 바이트 = 1,000 바이트
- 메가 바이트 = 1,000,000 바이트
- 기가 바이트 = 1,000,000,000 바이트

이만큼의 저장 공간 용량들이죠.

자료 구조를 배우면서 바이트나 다른 저장 공간 단위들을 심도 있게 다루지는 않을 건데요. 그래도 자료 구조에서는 이해하면 도움이 되는 개념/용어이니까,

1. 바이트는 컴퓨터 저장 공간 용량을 나태내는 단위다.
2. 메모리 한 칸에 담기는 데이터 용량은 1 바이트다.

이 정도는 이해하고 넘어가시면 나중에 나오는 내용을 이해하는 데 조금 더 수월할 거예요!

# 4. 레퍼런스(reference)

x = 95
파이썬에서의 이 식이 의미하는 바는 ‘x는 95를 가리킨다’는 맞는 표현이고 ‘x는 95다’는 틀린표현이다. 왜냐하면 x는 95가 저장된 메모리 주소를 저장하기 때문이다.
이렇게 데이터에 접근하게 하는 값을 레퍼런스(reference)라고 한다. 레퍼런스와 주소는 조금 다른데 주소는 메모리의 실질적인 주소를 이야기하고 레퍼런스는 추상적인 개념으로 **데이터에 접근할 수 있게 해주는 값을 ‘주소’보다 조금 더 포괄적인 표현**이다. 사실상 자료 구조를 배울 때는 ‘**주소 = 레퍼런스**’라고 생각해도 된다.

# 5. 데이터의 주소

## **파이썬 id 함수**

**`id`** 함수를 이용하면 저장한 데이터의 메모리 주소를 정수로 표현한 값을 알아낼 수 있습니다. 여러 타입의 데이터를 저장하고 **`id`** 함수를 써서 메모리 주소를 출력시켜보겠습니다.

```python
# 여러 데이터를 저장한다
list1 = [1, 2]
int1 = 0
float1 = 3.14
set1 = set()
tuple1 = (2, 3)

# 저장한 데이터의 메모리 저장 위치를 받아온다
print(id(list1))
print(id(int1))
print(id(float1))
print(id(set1))
print(id(tuple1))
#--==>>
'''
140237662138184
4450309504
140237661913472
140237664406888
140237662993992
'''
```

## **같은 주소에 저장돼 있는 데이터**

똑같은 주소에 저장돼 있는 데이터는 똑같은 데이터입니다.

```python
# 리스트를 정의한다
list1 = [1, 2]
list3 = [1, 2, 3]

# Aliasing을 통해 list1과 list2를 같게 한다
list2 = list1

# 두 데이터의 메모리를 출력한다
print(id(list1))  # 140657629409160
print(id(list2))  # 140657629409160
print(id(list3))  # 140657629409096
```

위 코드를 살펴봅시다. 세 변수 **`list1`**, **`list2`**, **`list3`** 를 만들었습니다.
`list1`은 정수 `1`, `2`를 그리고 `list3`은 **`1`**, **`2`**, **`3`** 을 담고 있는 리스트입니다.
그리고 **`list2`** 에  **`list1`** 를 지정했습니다. 메모리에서 만든 하나의 같은 리스트를 **`list1`**, **`list2`** 라는 두 개의 다른 변수가 가리키고 있는 거죠. 이렇게 여러 변수가 같은 메모리를 가리키는 것을 **Aliasing**이라고 합니다.
**`id`** 함수를 써서 **`list1`** 과 **`list2`** 의 메모리 주소를 출력해 보면 같다고 나오죠? **`list3`** 는 다른 주소에 저장되어 있습니다. **`list1`** 과 **`list2`** 는 서로 같은 리스트를 가리키고 있기 때문에 똑같은 메모리가 출력되고, **`list3`** 는 전혀 다른 리스트를 가리키고 있기 때문에 다른 메모리가 출력되는 거죠.