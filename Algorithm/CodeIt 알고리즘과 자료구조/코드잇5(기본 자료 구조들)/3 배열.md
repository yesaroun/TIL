

# 1. 배열이란

파이썬의 리스트는 다른 언어(C, Java)의 배열이랑은 다르다. 다른 언어의 배열은 연속된 값들이 저장되어 있기에 하나의 타입이어야 하고, 크기를 지정해야 한다. 하지만 파이썬의 리스트는 각각의 레퍼런스(주소)를 저장하고 있다. 그래서 다양한 타입도 가능하고, 크기를 변경할 수도 있다.

# 2. 배열 인덱스를 이용한 데이터 저장/접근법

배열에 데이터를 저장하고 가지고 오는 법을 보면 C언어의 예를 들면 int numArray[4];은 사용하고 있지 않고 연속적인 16칸을 예약한다. 이 배열에 값들이 순서대로, 그리고 연속적으로 저장된다. 

# 3. 배열 탐색

배열 접근 연산 : O(1)
배열 탐색 연산 : O(n)

# 4. 정적 배열

정적 배열 : 크기 고정(요소 수 제한)
동적 배열 : 크기 변홤(요소 계속 추가 가능)

# 5. 동적 배열(Dynamic Array)

정적 배열로 만들어진 자료 구조로 기존 배열이 가득 찼을때 적당한 크기로 늘려준다.

# 6. 파이썬 리스트(동적 배열)의 비밀

사실 우리는 이미 동적 배열을 사용하고 있었는데요. 파이썬 리스트가 바로 동적 배열입니다. C 배열을 이용해서 동적 배열을 구현한 거죠.
이렇게 5개의 정수 값이 들어간 파이썬 리스트를 만들었습니다. 파이썬 리스트는 동적 배열이기 때문에, 내부적으로는 C 배열이 만들어진 거죠.

```python
int_list = [2, 3, 5, 7, 11]
```

여기에 새로운 값을 추가할 수도 있습니다.

```python
int_list.append(13)
```

우리 입장에서는 내부적으로 얼마나 큰 배열이 있는지 몰라도, 값을 맘대로 추가할 수 있습니다. 동적 배열이기 때문에 상황에 맞게 배열 크기가 조절되고 있는 거죠.
그런데, 우리는 리스트를 사용할 때 현재 내부적으로 사용되고 있는 배열의 크기를 모릅니다. 아무리 저장한 데이터가 6개여도 내부적으로는 8개짜리 배열일 수도 있고, 12개짜리 배열일 수도 있고, 15개짜리 배열일 수도 있고 알 수가 없습니다.
그럼 만약 리스트의 길이를 출력하면 뭐가 나올까요? **`len`** 함수를 쓰면 길이를 알 수 있죠?

```python
print(len(int_list))
```

출력되는 결과를 보면…

```
6
```

**`6`** 이라고 나오는데요. 실제 사용하고 있는 메모리 공간이 더 많을지라도, 파이썬은 개수를 셀 때 값을 저장해 놓은 공간에 대해서만 알려 줍니다. 그래서 우리는 나머지 공간에 대해서 전혀 신경을 안 써도 됩니다.
오히려 채워지지 않은 공간을 접근하려고 하면…

```python
print(int_list[9])
```

오류가 납니다.
우리가 미리 값을 저장해 놓은 공간에만 접근할 수 있도록 파이썬이 미리 처리를 해 놓은 겁니다.
파이썬뿐만 아니라, 동적 배열을 자료형으로 제공하는 대부분의 언어들은 이렇게 실제 사용하는 배열의 크기와 상관없이 저장해 놓은 공간만 사용할 수 있게 처리를 해 줍니다.
뒤 레슨들에서 이 여유 공간은 항상 빈칸으로 표시할 건데요. 이 공간은 항상 개발자들이 접근할 수 없다고 가정할게요.

# 7. 동적 배열 추가 연산 시간 복잡도

배열의 끝에 새로운 요소를 받는 것을 추가 연산(append operation)이라고 한다. 동적 배열은 내부적으로 정적배열을 사용한다. 그래서 새 값을 채우려고 할때 아래와 같은 2가지의 경우가 있다.
경우 1: 정적 배열 남는 공간 있을 때
경우 2: 정적 배열이 꽉 찼을 때

## 경우 1: 정적 배열 남는 공간 있을 때: O(1)

남은 공간에 대입하면 되니까 O(1)이다.

## 경우 2: 정적 배열이 꽉 찼을 때: O(n)

값을 추가하기 위해서는 현재 사용중인 공간보다 2배로 큰 배열을 예약한다. 그리고 새로운 배열에 기존 배열의 값을 전체 다 복사한다. 그리고 새로운 값을 빈 칸에 추가한다.
기존에 저장되어 있는 값의 갯수를 n이라고 하면 n을 새 배열에 복사해야 한다. 이 과정은 n번 걸린다.(O(n)) 그리고 새 값을 추가하는 과정은 O(1)번 걸리니까 O(n+1)이 걸리고 즉 O(n) 걸린다.

결국 동적 배열을 추가하는 연산은 최고의 경우 O(1)이 걸리고 최악의 경우 O(n)이 걸린다. 

# 8. 분할 상환 분석 개념

추가 연산의 시간 복잡도는 최고의 경우(O(1))는 자주 일어나지만 최악의 경우(O(n))은 가끔 일어난다. 그래서 이는 비합리적이라는 생각이 든다. 보통 시간 복잡도는 최악의 경우를 이야기하는데 이게 비합리적인 경우 시간 복잡도를 다르게 계산하는 몇가지 방법이 있는데 그 방법중 하나인 분할 상환 분석(Amortized Analysis)를 알아보겠다.

## 분활 상환 분석(Amortized Analysis)

이건 쉽게 이야기해서 할부이다. 만약 같은 동작은 n번 했을 때 드는 시간이 X일 때, 그 동작을 한 번 하는데 걸린 시간을 X/n 라고 할 수 있는 것이다. 즉 시간복잡도를 평균을 내서 이야기 하는 것이다.

# 9. 분할 상환 분석 적용

분할 상환 분석은 연산을 n 번 했을 때 총 드는 시간 X를 n으로 나눠주는 “할부” 개념이라고 배웠는데요. 최악의 경우로 시간 복잡도를 얘기하는 것이 비합리적인 경우에 사용하죠. 이번 레슨에서는 동적 배열의 추가(append) 연산에 직접 분할 상환 분석을 해 봅시다.

## **동적 배열 동작**

동적 배열에 추가를 할 때는:
1. 새로운 인덱스에 데이터를 저장하는 시간
2. 기존 배열의 크기가 부족해서 더 큰 배열을 만들고, 기존 배열의 데이터들을 옮기는 시간
이 두 가지를 나눠서 생각하면 편합니다.

우선 기억을 상기시키기 위해서 동적 배열에 데이터를 추가할 때 일어나는 일들을 쭉 나열해 볼게요.
비어 있는 동적 배열에 추가 연산을 9번 한다고 가정합시다. 처음 시작할 때 동적 배열은 크기가 1인 배열입니다.

1. 첫 번째 요소 추가:
    1. 그냥 새로운 데이터를 저장합니다.
2. 두 번째 요소 추가:
    1. 배열이 꽉 찼습니다. 크기가 2인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다 (1 개 옮겨 저장)
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
3. 세 번째 요소 추가:
    1. 배열이 꽉 찼습니다. 크기가 4인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다 (2 개 옮겨 저장)
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
4. 네 번째 요소 추가
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
5. 다섯 번째 요소 추가
    1. 배열이 꽉 찼습니다. 크기가 8인 배열을 새로 만들고 기존 데이터를 옮겨 저장합니다 (4 개 옮겨 저장)
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
6. 여섯 번째 요소 추가
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
7. 일곱 번째 요소 추가
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
8. 여덟 번째 요소 추가
    1. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.
9. 아홉 번째 요소 추가
    1. 배열이 꽉 찼습니다. 크기가 16인 배열을 새로만들고 기존 데이터를 옮겨 저장합니다 (8 개 옮겨 저장)
    2. 맨 뒤 인덱스에 새로운 데이터를 저장합니다.

이런 식으로 내부 배열이 꽉 찼을 때는 새로운 배열을 만들고, 기존 요소들을 복사하고, 새로운 요소를 저장하면 됩니다. 그리고 배열에 여유가 있으면 그냥 새로운 요소만 저장하면 되죠?

## **분할 상환 분석**

분할 상환 분석을 하면 이 동작을 n 번 반복한다고 가정합니다. 총 걸리는 시간을 계산하기 쉽게 두 가지로 나눠서 생각해 볼 거라고 했잖아요?

1. 새로운 데이터를 동적 배열 맨 끝에 단순히 저장하는 데 걸리는 시간
2. 더 큰 배열을 만들고 그 배열에 기존의 데이터를 옮기는 데 걸리는 시간

걸리는 두 시간을 각각 따로 계산해 볼게요.

### **배열 끝에 새로운 데이터 저장하는 데 걸리는 시간**

먼저 새로운 데이터를 저장하는 데 걸리는 총 시간에 대해서 생각해 봅시다.

| x 번째 추가|배열 끝에 데이터 저장하는 데 걸리는 시간|
| --- | --- | 
| 1 | 1 |
| 2 | 1 |
| 3 | 1 |
| 4 | 1 |
| 5 | 1 |
| ... | 1 |
| n | 1 |

인덱스에 데이터를 저장하는 데 걸리는 시간은 1이라고 했잖아요? 이걸 총 n 번 하는 거니까 O(n)이 걸리겠죠?

### **새로운 배열에 데이터 옮기는 시간**

이번에는 내부 배열이 꽉 차서 기존 데이터를 복사하는 데 걸리는 시간에 대해서 생각해 봅시다. 

| x 번째 추가|배열 크기|새로운 배열에 요소 옮겨 저장하는 데 걸린 시간|
|--|--|--|
|1|1|0|
|2|2|1|
|3|4|0|
|4|8|4|
|5|8|0|
|6|8|0|
|n| | |

새로운 배열에 기존 데이터를 옮겨 저장하는 시간은 위 표에 나와 있는대로 소요됩니다.
표를 살펴봅시다. 2 번째, 3 번째, 5 번째, 9 번째 추가 때 배열의 크기를 늘려야 합니다. 그럴 때마다 데이터를 옮겨야 하는데요. 이때 데이터를 각각 1, 2, 4, 8 개씩 복사하고 붙여 넣습니다.
데이터를 복사해서 붙여 넣는 총 시간 비용은 이 시간들을 더한 8 + 4 + 2 + 1인데요. 좀 더 일반화해서 생각할까요?
추가 연산을 n 번 했을 때, 가장 마지막에 데이터를 m 개 옮겨서 저장했다고 합시다.
그럼 데이터를 복사해서 저장하는 데 걸린 총 시간은 : m + m/2 + m/4 + … + 1 이렇게 표현할 수 있는데요. 이걸 도형으로 나타내 볼게요. 이런 식으로 처음에 m이 있고 그 다음에 계속 반으로 줄어든 값을 더해 주겠죠?

![[Pasted image 20221026002718.png]]
처음에 이렇게 더해 주다가, 결국에는 이렇게 될 텐데요.

![[Pasted image 20221026002731.png]]

도형에서 볼 수 있듯이 이런 식으로 어느 자연수든 반씩 줄여서 1까지 계속 더해주면 그 결과는 절대 2m을 넘을 수 없습니다. 정확히 말하면 딱 2m - 1이 되죠.
근데 가장 최근에 데이터를 옮겨 저장할 때 8이 걸렸다는 건 무슨 의미일까요? 원래 배열의 수용 가능 크기가 8이었지만 크기가 부족해서 16개의 데이터를 담을 수 있는 새로운 배열로 복사했다는 얘기인데요. 그럼 결국에 현재 배열 안에 있는 데이터는 9개에서 16개 사이라는 말입니다. 16개보다 더 많은 요소가 있으면 가장 최근에 옮겨 저장한 요소의 수가 8이 아니라 16이겠죠?
이 사실을 바탕으로 우리가 일반화할 때 사용했던 배열 안 요소 수 n과 가장 최근 옮겨 저장한 요소 수 m의 관계에 대해서 한 가지 사실을 알아낼 수 있는데요.
가장 최근에 복사하는 데 걸린 시간이 8일 때, 배열 안에 있는 데이터는 9개에서 16개 사이입니다. 즉, m은 무조건 n보다 작다고 할 수 있습니다.
추가 연산을 연속으로 n번 하고, 가장 마지막에 옮겨 저장한 데이터 요소 수를 m이라고 할 때:

- 복사해서 저장하는 데 걸리는 총 시간이 2*m*−1이고
- m은 *n* 보다 작습니다.

이걸 다시 정리해서 나타내면:

> 연속으로 추가 연산을 n 번을 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 2n 보다 작다!
> 

라고 할 수 있습니다.

## **두 경우 합치기**

지금까지 나온 내용을 종합해 보면, 동적 배열에 n개의 데이터를 연속으로 추가하면:

1. 새로운 데이터를 저장하는 데에는 *n*의 시간이 들고,
2. 데이터를 옮겨 저장하는 데에는 2*n*보다 적은 시간이 걸리는데요.

이 두 시간을 합치면 총 드는 시간은 3n보다 적은 시간이 걸리겠죠? 이걸 시간 복잡도로 표현하면 O(3n), 그러니까 O(n)이라고 할 수 있습니다.
근데 이건 추가 연산을 한 번 하는 게 아니라 연속으로 n 번 하는 데 걸리는 시간 복잡도입니다.
그러니까 총 n 번의 추가 연산을 하는 데 걸리는 시간이 O(n)인 건데요. 추가 연산을 n 번 하는 데 O(n)의 시간이 걸리니까 1 번 하는 데는 O(n)/n, 즉 *O*(1)이 걸리는 거죠.
전에는 추가 연산이 최악의 경우 O(n)이 걸린다고 했었는데요. 분할 상환 분석을 하면 O(1)이 걸린다고 보는 거죠.

## **최악의 경우 분석 vs. 분할 상환 분석 뭘 쓰면 되는 걸까**

사실 분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아닙니다. 보통은 할부 개념을 적용해도 시간 복잡도가 줄어들지 않죠.
하지만 만약 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적다면, 분할 상환 분석을 한 시간 복잡도를 사용합니다. 그러니까 “동적 배열의 끝에 데이터를 추가할 때는 O(1)이 걸린다.”라고 표현해도 된다는 거죠.

보통은 혼란을 없애기 위해 좀 더 정확하게:

> 동적 배열의 추가(append) 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.
> 

라고 표현할 수 있습니다!

# 10. 동적 배열 삽입 연산

데이터를 추가(append) 한다는 표현은 동적 배열 끝에 추가하는 경우 사용하는 표현이고,
데이터를 삽입(insertion)은 아무 위치에 넣는 경우 사용하는 표현이다. 
데이터 삽입도 추가와 마찬가지로 배열에 여유 공간이 있을때와 꽉 찼을 때 두 가지 경우로 나뉜다.
경우 1: 정적 배열 남는 공간 있을 때
경우 2: 정적 배열이 꽉 찼을 때

### 경우 1: 정적 배열에 남는 공간 있을 때 시간 복잡도: O(n)

배열은 요소들이 연속되어 저장되어 있는데 중간에 넣으려면 삽입하려고 하는 인덱스 뒤에 모든 요소들을 한 인덱스씩 뒤로 밀어 넣어줘야 한다. 이 경우 시간 복잡도는 최악의 경우를 생각하므로 인덱스 0에 삽입하는 경우를 생각한다. 그러면 n개의 데이터 모두를 뒤로 보내야 한다. 그래서 뒤로 미는 경우 O(n)이 걸리고 맨 앞에 삽입하는 경우 O(1)이 걸린다. 즉 총 시간은 O(n + 1)이고 O(n)이다. 

### 경우 2: 정적 배열이 꽉 찼을 때 시간 복잡도: O(n)

공간이 부족해 새로운 배열을 만들고 기존 배열을 복사한다. 그리고 수용 공간이 남아있을때와 똑같이 뒤로 밀고 삽입한다. 배열 안에 n개 요소가 있을 때, 새로운 배열을 만들고 이 배열에 기존 요소들을 하나씩 옮기는데 걸리는 시간 복잡도는 O(n)이다. 그 다음 원하는 위치에 공간을 만들기 위해서 모든 요소를 한칸씩 뒤로 밀면 최악의 경우(인덱스 0에 삽입) O(n)이다. 마지막으로 새로운 데이터를 저장하는 O(1)이 걸린다.
즉, 새로운 요소들을 복사 할때 O(n), 원하는 인덱스에 자리를 만들때 O(n), 인덱스에 저장하는 O(1)이 걸린다.(O(n) + O(n) + 1) 이는 O(2n + 1)이고 결국 O(n)인거다.

## 삽입 연산(insert operation)의 시간 복잡도: O(n)

삽입 연산의 시간 복잡도는 

경우 1: 정적 배열에 남는 공간 있을 때: O(n)
경우 2: 정적 배열이 꽉 찼을 때: O(n)

즉, 삽입 연산의 시간 복잡도는 O(n)이다.

# 11. 동적 배열 삭제 연산

## **삭제 연산 동작**

**`2`**, **`3`**, **`5`**, **`7`**, **`11`** 이 있는 동적 배열에서 인덱스 1에 있는  **`3`** 을 지우고 싶다고 할게요.

![[Pasted image 20221026002800.png]]

1. 인덱스 1 뒤에 있는 데이터를 모두 한 칸씩 앞으로 밀어서 저장합니다.
    1. 인덱스 1에 인덱스 2에 있던 **`5`** 를 저장합니다
    2. 인덱스 2에 인덱스 3에 있던 **`7`** 을 저장합니다
    3. 인덱스 3에 인덱스 4에 있던 **`11`** 을 저장합니다
2. 동적 배열은 배열의 크기와 개발자가 사용하는 인덱스들의 범위를 따로 관리합니다. 데이터를 삭제했으니까 동적 배열에서 접근할 수 있는 인덱스 범위도 1을 줄여 줍니다.
![[Pasted image 20221026002814.png]]

동적 배열에 남은 데이터를 확인해보면 **`2`**, **`5`**, **`7`**, **`11`** 입니다. 
요약하자면, 삭제 연산은 그냥 삭제하고 싶은 데이터 뒤에 있는 모든 데이터 요소들을 한 칸씩 앞으로 밀어서 저장하면 됩니다.

## **삭제 연산 시간 복잡도**

전 레슨들에서는 데이터를 아무 위치에나 더해 주는 삽입(insert) 연산과 맨 끝에 더해주는 추가(append) 연산을 나눠서 생각했었는데요. 삭제 연산도 아무 위치의 데이터를 삭제할 때와 맨 뒤 데이터를 삭제할 때, 두 경우를 나눠서 생각할 수 있습니다.

### **맨 앞 데이터를 지울 때 (최악의 경우)**

삭제 연산이 가장 오래 걸리는 경우는 가장 앞 인덱스에 있는 데이터를 지우는 경우입니다.
가장 앞 데이터를 삭제할 때는 인덱스 1부터 끝까지 모든 요소들을 한 칸씩 앞으로 밀어서 저장해야 됩니다. 그러니까 삭제하기 전 배열 안에 총 n 개의 데이터가 남아 있으면, 총 n - 1개의 요소들을 하나씩 앞 칸으로 밀어서 저장해야 되는 거죠. 이 횟수가 n에 비례하기 때문에 O(n)이 걸린다고 할 수 있죠. 
종합해 보면 삭제 연산은 총 O(n)이 걸린다고 할 수 있습니다. 

### **맨 뒤 데이터를 지울 때**

맨 뒤 데이터를 삭제할 때는 아무 요소도 안 밀고 저장해도 되고, 그냥 동적 배열의 사용 공간을 한 인덱스 줄이면 됩니다.
이건 배열에 데이터 요소가 몇 개가 있는지에 상관이 없이 일정한 시간에 할 수 있습니다. O(1)이라고 할 수 있는 거죠.

## **정리**

동적 배열의 아무 위치에 데이터를 삭제할 때는 원하는 위치 뒤에 있는 데이터를 옮겨 저장해야 됩니다. 그래서 최악의 경우 O(n)이 걸립니다.
하지만 가장 뒤에 있는 데이터를 삭제할 때는 다른 데이터를 옮겨 저장할 필요가 없습니다. 따라서 O(1)이 걸립니다.

# 12. 동적 배열 크기 줄이기

## **동적 배열 크기 줄이기**

동적 배열은 내부적으로 정해진 크기의 정적 배열을 사용하고 있습니다. 값을 추가하다가 내부 배열이 꽉 차면, 더 큰 내부 배열을 사용하도록 자동으로 늘려 주는 거죠. 반대로 삭제를 할 때에는 내부 배열의 크기를 줄이기도 합니다.

## **왜 내부 배열의 크기를 줄여야 될까?**

데이터 요소 10000 개가 들어 있는 동적 배열이 있다고 생각해 봅시다. 편의상 배열의 크기가 꽉 찼다고 생각할게요. 여기서 요소 9900 개를 삭제하면 100 개밖에 남지 않는데요. 그러면 나머지 9900 개의 요소를 저장할 수 있는 메모리는 낭비되겠죠? 동적 배열은 요소의 개수가 어느정도 줄어들면 내부 배열의 크기도 적절히 줄여서 공간을 좀 더 효율적으로 사용합니다.

## **내부 배열의 크기는 어떻게 줄어들까?**

![[Pasted image 20221026002837.png]]

위의 동적 배열 **`int_array`** 를 봅시다. **`int_array`** 는 9 개의 요소를 담고 있습니다. 내부 배열 크기가 9 개인 꽉 찬 동적 배열이라고 할게요.
여기서 맨 뒤 요소 6 개를 삭제합니다.

![[Pasted image 20221026002849.png]]

그럼 요소가 3 개로 줄어들죠? 그럼 정수 6 개를 저장할 수 있는 공간이 낭비되네요. 이렇게 낭비하는 공간이 너무 많아지는 경우에 내부 배열의 크기를 줄일 수 있습니다.

그런데 정확히 어떤 시점에 줄이면 좋을까요?
크기를 늘릴 때는 내부 배열이 꽉 찼을 때였는데요. 크기를 줄일 때는 내부 배열의 사용 비율이 특정 값 이하로 떨어질 때입니다.
이 비율이 1/3이라고 가정하고 볼게요. 요소가 4 개에서 3 개로 줄어든 상황이라고 합시다. 내부 배열에 요소 9 개를 담을 수 있는데, 현재 사용 중인 공간은 3 칸밖에 없습니다. 그러니까 총 사용할 수 있는 공간 중 1/3 밖에 사용을 안 하게 된 거죠.

이때:

1. 새로운 내부 배열을 정의합니다. 이번에는 크기가 3인 내부 배열을 만듭니다:
    
	![[Pasted image 20221026002908.png]]
1. 그리고 기존의 3 개 요소를 새로 만든 내부 배열에 옮겨서 저장합니다:
    
    ![[Pasted image 20221026002918.png]]
    

전에는 6 칸을 낭비하고 있었는데 이제는 낭비하는 공간이 하나도 없습니다.
내부 배열의 크기를 요소 수에 맞게 줄이면, 낭비하는 공간을 최소한으로 할 수 있습니다.
그렇다고 방금 예시처럼 꼭 사용 비율이 1/3일 때 크기를 줄여야 하는 것은 아닙니다. 1/2, 1/4, 1/5 일 때 줄일 수도 있죠. 개발자나 프로그래밍 언어에 따라 이 비율은 다릅니다.
일단 저희는 생각하기 편하게 내부 배열의 크기를 늘릴 때에는 2 배로 늘리고, 줄일 때에는 요소 수가 크기의 1/2 가 됐을 때 줄인다고 가정할게요.

## **시간 복잡도**

### **동적 배열 맨 끝 데이터 삭제 시간 복잡도**

맨 끝 요소를 삭제했을 때 걸리는 시간 복잡도에 대해서 생각해 봅시다.
최악의 경우를 가정합시다. 가장 오래 걸리는 경우는, 더 작은 배열로 모든 요소들을 옮겨 저장해야 될 때인데요.
배열 안에 있는 요소 수가 n이라고 할 때, 총 n 개의 데이터를 모두 새 배열에 복사해서 넣어야겠죠. 맨 뒤 데이터를 삭제하는 건 O(1)이 걸립니다. 하지만 n 개의 데이터를 모두 새 배열에 복사해서 넣어야 되기 때문에 n에 비례하는 시간, O(n)이 걸립니다.

### **맨 끝 데이터 삭제 분할 상환 분석**

하지만 내부 배열의 크기가 줄어드는 건 드문 경우입니다. 대부분의 경우 그냥 마지막 인덱스에 있는 데이터를 지워 주기만 하면 됩니다.
위에서 봤던 예시를 다시 생각해 봅시다. 요소가 9 개에서 3 개로 줄어들 때까지, 그러니까 마지막 데이터 6 개를 삭제할 동안 배열의 크기를 조절할 필요가 없었습니다. 이 6 번은 그냥 O(1)로 맨 끝 데이터를 삭제한 거죠.
근데 요소 수가 4 개에서 3 개로 줄어들 때에는, 마지막 데이터를 삭제하고 남은 3 개의 데이터를 새롭게 만든 더 작은 배열로 복사해서 저장했습니다. 이 경우에 O(n)이 걸린 거죠.
동적 배열에서 마지막 데이터를 삭제할 때는 대부분의 경우 O(1)이 걸리지만, 드물게 O(n)이 걸립니다. 그렇기 때문에 추가 연산과 마찬가지로 분할 상환 분석을 적용할 수 있습니다. 분할 상환 분석을 적용하면 맨 끝 데이터 삭제 연산도 O(1)이 걸린다고 이야기할 수 있습니다.

## **정리**

> 동적 배열에서 맨 끝 데이터를 삭제하는 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 적용하면 O(1)이라고 할 수 있다.
> 

# 13. 배열과 동적 배열 정리/비교

## 연산&시간 복잡도

|—|배열|동적 배열|
|--|--|--|
|접근(access)|O(1)|O(1)|
|탐색(search)|O(n)|O(n)|
|삽입(insert)|N/A|O(n), 맨뒤 O(1)|
|삭제(delete)|N/A|O(n), 맨뒤 O(1)|

n: 배열 요소 수

## 낭비하는 공간

배열 : 크기가 고정되어 있기 때문에 낭비하는 공간이 없다.

동적 배열 : 공간을 낭비할 수도 있고 낭비하지 않을 수도 있다.

# ***14. 정적 배열에 삽입과 삭제를 못하는 이유***

|연산|배열 시간 복잡도|
| --- | --- |
|접근 (access)|O(1)|
|탐색 (search)|O(n)|
|삽입 (insert)|N/A|
|삭제 (delete)|N/A|

챕터 정리 레슨에서 배열에는 삽입과 삭제 연산을 자연스럽게 할 수 없다고 했습니다. 두 연산의 시간 복잡도를 N/A, 해당 사항 없음으로 표기했죠? 이번 노트에서 왜 그런지 알아볼게요. C 배열을 써서 보여드릴게요.

# **배열에 데이터 삽입을 못하는 이유**

이건 정적 배열의 한계 레슨에서 이미 배운 내용이긴 한데요. 복습한다는 생각으로 보세요!

```c
int numArray[4];

numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```

배열에 삽입을 못하는 이유는 직관적입니다.
이렇게 정수형 데이터 4 개를 저장하는 배열을 정의했다고 할게요. 배열은 크기가 정해져 있습니다. 더 많은 데이터 요소들을 저장하고 싶으면 더 큰 배열을 정의해야 되죠. 사용하고 싶은 요소 수에 따라 크기를 바꿀 수 있으면 그건 배열이 아니라 동적 배열이겠죠?
크기가 고정되어 있는 배열에는 처음 정한 수보다 더 많은 데이터를 삽입할 수가 없는 거죠.

# **배열에 데이터 삭제를 못하는 이유**

이번에는 삭제를 못하는 이유를 알아봅시다.

```c
int numArray[4];

numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
```

정수 4개를 담을 수 있는 배열에 **`2, 3, 5, 7`** 이 저장돼 있다고 할게요. 여기서 인덱스 1에 있는 **`3`** 을 지우고 싶으면 어떻게 하면 될까요?
동적 배열 삭제 연산처럼 배웠던 거처럼 인덱스 1 자리에 인덱스 2의 데이터를 저장하고, 인덱스 2에 인덱스 3 데이터를 저장해서 **`2, 5, 7, 7`** 이렇게 하면 될 거 같긴 한데요.
여기서 문제는 인덱스 3에 저장되어 있던 **`7`** 을 메모리에서 자연스럽게 지울 수 있는 방법이 마땅히 없습니다. 비었다는 것을 표시하기 위해서 파이썬에서는 **`None`**, 다른 언어들에서는 **`Null`** 이런 값을 넣는 걸 생각하실 수 있는데요. **`numArray`** 는 정수형 데이터를 4 개를 저장합니다. **`None`** 이나 **`Null`** 은 정수형이 아닙니다. **`numArray`** 의 인덱스 3에 저장할 수 없습니다.
정리하자면 배열 **`numArray`** 에서 인덱스 1을 지우기 위해서는 **`2, 3, 5, 7`** 의 데이터를 **`2, 5, 7`** 으로 만드는 게 아니라 **`2, 5, 7, 7`** 이런 식으로 밖에 못 만듭니다.
지우고 싶은 요소를 “자연스럽게” 삭제할 수 없는 거죠.

# **동적 배열 삭제와 차이**

배열을 사용하는 동적 배열에서는 어떻게 데이터를 삭제할 수 있는지 생각해볼게요.
파이썬 리스트의 비밀 레슨 기억나시나요? 많은 언어들 자체적으로 제공하는 동적 배열은 사용하는 배열의 크기와 사용하는 인덱스 범위를 따로 처리한다고 했습니다.
동적 배열이 내부적으로 정수 4개를 저장할 수 있는 배열에 **`2`**, **`3`**, **`5`**, **`7`** 을 저장하고 있다고 할게요. 동적 배열에서 인덱스 1을 삭제하고 싶으면 인덱스 1에 5를 저장하고, 인덱스 2에 7을 저장합니다. 그럼 내부적으로는 **`2, 5, 7, 7`** 이렇게 저장되어 있을 텐데요. 그다음에 인덱스 3에 있는 7을 지우는 게 아니라 파이썬 내부적으로 개발자가 접근할 수 있는 인덱스 범위를 0 ~ 2로 만들어 버립니다. 더 이상 인덱스 3에 접근할 수 없게 만드는 거죠.
실제로 인덱스 3에 어떤 값이 저장되어 있던 상관없이 개발자는 더 이상 거기 접근할 수 없습니다. 동적 배열에서 접근할 수 있는 데이터가 **`2, 5, 7`** 밖에 없으니까 실질적으로 삭제됐다고 할 수 있는 거죠.