# 1. 자료구조의 이해

## 1) 자료구조의 개념

데이터의 특징을 고려하여 데이터를 저장하는 방법을 자료구조(data structure)라고 한다. 자료구조는 특징이 있는 정보를 메모리에 효율적으로 저장 및 반환하는 방법으로, 데이터를 관리하는 방식이다.

## 2) 파이썬에서의 자료구조

|자료구조명|특징|
|--|--|
|스택(stack)|나중에 들어온 값을 먼저 나갈 수 있도록 해주는 자료구조(last in first out)|
|큐(queue)|먼저 들어온 값을 먼저 나갈 수 있도록 해 주는 자료구조(first in first out)|
|튜플(tuple)|리스트와 같지만, 데이터의 변경을 허용하지 않는 자료구조|
|세트(set)|데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조|
|딕셔너리(dictionary)|전화번호부와 같이 키(key)의 값(value) 형태의 데이터를 저장하는 자료구조, 여기서 키값은 다른 데이터와 중복을 허용하지 않음 (자바의 map과 동일)|
|collections 모듈|위에 열거된 여러 자료구조를 효율적으로 사용할 수 있도록 지원하는 파이썬 내장(bult-in)모듈|

# 2. 스택과 큐

## 1) 스택(stack)

스택을 간단히 표현하면 LIFO(Last In First Out)으로 정의할 수 있다. 즉, 마지막에 들어간 데이터가 가장 먼저 나오는 형태로, 데이터의 저장 공간을 구현하는 것이다. 스택에서 데이터를 저장하는 것을 푸시(push), 데이터를 추출하는 것을 팝(pop)이라고 한다.

![[Pasted image 20220904144833.png]]

## 2) 스택의 사용 용도

웹 브라우저에서 앞으로 가기, 뒤로 가기를 보면 방문 기록이 점점 쌓인다. 뒤로 가기 누르면 스택을 두개를 이용해서 새로운 스택으로 넘어가고 또 누르면 다른 스택에 쌓이다가, 앞으로가기 누르면 새로운 스택에서 이전 스택으로 왔다갔다 한다. ctrl+z도 스택으 이용한 것이다. 파이썬에서는 리스트를 사용하여 스택을 구현할 수 있다. 리스트라는 저장 공간을 만든 후, append() 함수로 데이터를 저장(push)하고 추출(pop)한다. 파이썬에서는 스택 라이브러리를 제공하는데 collections 모듈에서 deque라는 자료구조를 제공하여 조금 더 빠르게 스택을 구현할 수 있다.

## 3) 스택으로 만들 수 있는 프로그램

예로 입력한 텍스트이 역순을 추출하는 프로그램을 작성할 수 있다.

```python
world = input("Input a word: ")
world_list = list(word)
print(word_list)

result = []
for _ in range(len(world_list)):
		result.append(world_list.pop())
print(result)
print(world[::-1])
#--==>>
'''
Input a word: PYTHON 
['P', 'Y', 'T', 'H', 'O', 'N']
['N', 'O', 'H', 'T', 'Y', 'P']
NOHTYP
'''
```

cf) _ 기호는 일반적으로 for문에서 많이 쓰이는데, for문에 기호가 있으면 해당 반복문에서 생성되는 값은 코드에서 사용하지 않는다는 뜻이다. 코드에서는 range(len(world_list))에서 생성된느 값이 반복문 내에서 사용되지 않으므로 _로 할당받는 것이다.

## 4) 큐(Queue)

큐(queue)는 스택과 다르게 먼저 들어간 데이터가 먼저 나오는 FIFO(First in FirstOut)의 메모리 구조를 가지는 저장 체계이다. 삽입시 offer(), 추출시 poll()을 사용한다.

![[Pasted image 20220904144852.png]]

# 3. 튜플

## 1) 튜플(tuple)의 개념

튜플은 리스트와 유사하지만 튜플의 내용은 변경될 수 없다. 리스트는 변경될 수 있는 객체이기 때문에 실수로 요소가 추가되거나 삭제, 변경될 수 있기 때문에 이를 방지하기 위해 튜플을 사용하고 또 튜플은 리스트에 비하여 접근 속도가 빠르다. 튜플도 시퀀스의 일종이다. 시퀀스에 속하는 자료 구조들은 동일한 연산(인덱싱, 슬라이싱, 덧셈연산, 곱셉연산)을 지원한다.

### e.g.

```python
colors = ("red", "green", "blue")

t = (1 , 2, "hello")     
# 튜플도 리스트와 마찬가지로 여러 가지 자료형의 값을 섞어서 생성할 수 있지만 권장하지 않음

num = (10, )
# 하나의 값만을 가진 튜플을 생성할 때는 반드시 값 다음에 쉼표를 붙여야 한다.

t = tuple([1, 2, 3])
# 리스트로부터 튜플을 생성할 수 있다.

t = (1, 2, 'hello')
u = t, (1, 2, 3, 4)
print(u)
#--==>> ((1, 2, 'hello'), (1, 2, 3, 4))
# 튜플도 리스트와 마찬가지로 내부에서 다른 튜플을 가질 수 있다.
```

## 5) 튜플 내장 함수

![[Pasted image 20220904144913.png]]

## 6) 튜플 대입 연산

파이썬은 튜플 대입 연산(tuple assignment)이라는 기능을 가지고 있으며 이 기능은 튜플에서 여러 개의 변수로 한번에 값을 대입하는 강력한 기능이다.

```python
student1 = ("철수", 19, "CS")
(name, age, major) = student1
print(name)
print(age)
print(major)
#--==>>
'''
철수
19 
CS
'''
```

튜플에 값을 저장하는 과정을 튜플 패킹(tuple packing)이라고 하고 반대로 튜플에서 값을 꺼내서 변수에 대입하는 과정을 튜플 언패킹(tuple unpacking)이라고 한다. 튜플 대입 연산을 가장 효과적으로 사용하는 예가 변수의 값을 교환하는 경우이다.

```python
temp = x
x = y
y = temp
# 이 코드를 아래처럼 쓸 수 있다.
(x, y) = (y, x)
```

단, 변수의 개수와 값의 개수는 일치해야 한다.

# 4. 세트(set)

## 1) 세트(set)

세트는 수학에서 배운 집합이다. 세트의 항목간에는 순서가 없다. 만약 응용 프로그램에서 순서 없는 항목들의 집합을 원한다면 세트가 최선의 선택이지만 중복된 항목이 없어야 한다.

```python
세트 = {항목1, 항목2, 항목n}
```

**중복을 불허하는 특징 때문에 프로그래밍에서 매우 유용하다. 대표적으로 문서 하나에 들어가 있는 단어 종류의 개수를 셀 때 모든 단어를 추출한 후 세트로 변환하면, 단어 종류의 개수를 쉽게 파악할 수 있다.**

```python
numbers = {2, 1, 3}
```

```python
mySet = {1, 2.3, 'hello', (1, 2)}
# 여러 가지 자료형을 섞어도 된다.

cities = {"paris", "seoul", "london", "paris", "seoul"}
print(cities)
#--==>> {'london', 'seoul', 'paris'}
# 세트는 집합이기 때문에 요소가 중복되면 자동으로 중복된 요소를 제거한다!!    <-- check***

numbers = set()
# 비어 있는 세트를 생성하려면 set()함수를 사용한다.

numbers = {2, 1, 3}
if 1 in numbers:
    print("집합 안에 1이 있습니다.")
#--==>> 집합 안에 1이 있습니다.
# 어떤 항목이 세트 안에 있는지 검사하려면 in 연산자를 사용하면 된다.

for x in numbers:
    print(x, end=" ")
#--==>> 1 2 3
# 세트의 항목은 순서가 없기 때문에 위치를 가지고 세트의 항목에 접근할 수는 없다.
# 하지만 for문을 이용해 각 항목들에 접근할 수 있다.
# 여기서 주의할 점은 항목들이 출력되는 순서는 입력된 순서와 다를 수 있다!!    <-- check***

for x in sorted(numbers):
    print(x, end=" ")
#--==>> 1 2 3
# 만약 정렬된 순서로 항목을 출력하기를 원한다면 sorted()함수를 사용하면 된다.
```

세트는 모든 요소들을 해싱(hashing)을 이용하여 저장하고 관리한다. 따라서 요소들은 해싱가능(hashable)하어야 한다. **해싱이란 각각의 객체에 식별할 수 있는 숫자 코드를 부여하여 객체를 테이블에 저장하는 것이다.** 파이썬에서 요소가 해싱 가능하려면 해쉬 코드를 가져야 하고 그 값이 변경되면 안된다. 따라서 세트는 변경 가능한 항목을 가지면 안된다. 예를 들어 세트 안에 리스트를 넣으면 안된다.

```python
numbers = {1, 2, [3, 4, 5]}
#--==>> TypeError

# 하지만 리스트로부터 세트를 생성하는 것은 가능하다.
print(set([1, 2, 3, 1, 2, 3]))
#--==>> {1, 2, 3}      # 중복 제거

# 문자열로부터 세트를 생성하는 것도 가능하다.
print(set("abcdefa"))
#--==>> {'f', 'a', 'b', 'e', 'c', 'd'}    # 중복 제거, 출력결과도 매번 다를 수 있다.
```

## 2) 요소 추가하고 삭제하기

**세트는 변경 가능한 객체이다. 따라서 세트에 요소를 추가하거나 삭제할 수 있다. 그러나 세트의 요소에는 인덱스가 없기 때문에 인덱싱이나 슬라이싱 연산은 의미가 없다.**

```python
numbers = {2, 1, 3}
print(numbers[0])
#--==>> TypeError: 'set' object is not subscriptable
```

add() 메소드를 이용하여 하나의 요소를 추가할 수 있다.

```python
numbers.add(4)
print(numbers)
#--==>> {1, 2, 3, 4}
```

여러 개의 요소는 **update()** 메소드로 추가할 수 있다. 물론 중복된 요소는 추가되지 않는다.

```python
numbers.update([2, 3, 4, 5])
print(numbers)
#--==>> {1, 2, 3, 4, 5}
```

요소를 삭제할 때는 **discard()** 메소드를 사용할 수 있다.

```python
numbers.discard(5)
print(numbers)
#--==>> {1, 2, 3, 4}
```

**remove()** 메소드도 사용할 수 있다. 만약 세트에 없는 요소를 삭제하려고 하면 remove()는 예외를 발생시킨다.

```python
numbers.remove(6)   # 세트에 6이 없으므로 예외 발생
#--==>> KeyError: 6
```

**clear()** 메소드는 세트의 전체 요소를 지운다.

```python
numbers.clear()     # 세트의 크기다 0이 된다.
print(len(numbers))
#--==>> 0
```

## 3) 부분 집합 연산

==와 =! 연산을 사용해 2개의 세트가 같은지도 검사할 수 있다.

```python
A = {1, 2, 3}
B = {1, 2, 3}
print(A == B)
#--==>> True
```

< 연산자와 ≤ 연산자를 사용하면 세트가 진부분 집합인지, 부분 집합인지를 검사할 수 있다. >와 ≥ 연산자를 사용하면 진상위 집합(A ) B 이고 A =/= B 인 경우 진상위 집합이라고 한다. 즉 상위집합이지만 두 집합이 같지 않다.), 상위 집합도 검사할 수 있다.

```python
A = {1, 2, 3, 4, 5}
B = {1, 2, 3}
print(B < A)
#--==>> True
```

부분집합인지를 검사하는 메소드는 **issubset**()이다.

```python
A = {1, 2, 3, 4, 5}
B = {1, 2, 3}
print(B.issubset(A))
#--==>> True
```

상위집합인지를 검사하는 메소드는 **issuperset()**이다.

```python
A = {1, 2, 3, 4, 5}
B = {1, 2, 3}
print(A.issuperset(B))
#--==>> True
```

요소가 집합에 포함되어 있는지는 in 키워드를 이용하여 검사할 수 있다.

```python
mySet = set("banana")
print('a' in mySet)
#--==>> True
print('p' not in mySet)
#--==>> True
```

## 집합 연산

**세트가 유용한 이유는 교집합이나 합집합과 같은 여러 가지 집합 연산을 지원하기 때문**이다. 다음과 같은 2개의 집합이 세트로 정의되어 있다고 가정한다.

```python
A = {1, 2, 3}
B = {3, 4, 5}
```

**합집합은 | 연산자나 union() 메소드를 사용한다.**

```python
print(A|B)
#--==>> {1, 2, 3, 4, 5}
print(A.union(B))
#--==>> {1, 2, 3, 4, 5}
```

**교집합은 & 연산자나 intersection() 메소드를 사용한다.**

```python
print(A & B)
#--==>> {3}
print(A.intersection(B))
#--==>> {3}
```

**차집합은 - 연산자나 difference() 메소드를 사용한다.**

```python
print(A - B)
#--==>> {1, 2}
print(B.difference(A))
#--==>> {4, 5}
```

집합에 대해서도 all(), any(), enumerate(), len(), max(), min(), sorted(), sum() 등의 메소드는 사용하 수 있다. **all()은 세트의 모든 요소가 True인 경우에 세트가 True가 된다. any()는 하나의 요소라도 True이면 True를 반환한다.**
