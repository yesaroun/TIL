# 1. String 클래스

일반적으로 인스턴스를 생성할 때는 이렇게 생성자를 통해서 만들죠?
```java
char data[] = {'a', 'b', 'c'};
String myString = new String(data);
//--==>> abc
```
하지만 문자열의 경우에는 '문자열 리터럴(String Literal)'로 만들기 때문에 기본형이 아닌가 오해를 할 수도 있습니다.
```java
String myString = "abc";
```
어쨌든 문자열도 클래스 기반의 자료형이기 때문에 여러 가지 메소드를 사용할 수 있는데요. 유용해보이는 몇 가지만 살펴보겠습니다.

# **대소문자 변환**
**`toUpperCase`** 메소드를 이용하면 모든 글자를 대문자로, **`toLowerCase`** 메소드를 이용하면 모두 소문자로 변환할 수 있습니다.
```java
String myString = "aBc";
System.out.println(myString.toUpperCase());  // 모두 대문자로
System.out.println(myString.toLowerCase());  // 모두 소문자로
System.out.println(myString)                 // 그대로
//--==>>
/*
ABC
abc
aBc
*/
```
참고로 이 두 메소드는 **`myString`** 자체를 바꾸는 것이 아니라, 새로운 문자열을 리턴시켜주는 것입니다. 따라서 마지막에 **`System.out.println(myString)`** 을 하면 원래대로 **`"aBc"`** 가 나오는 거죠.

# **문자열 비교**

```java
String myString = "aBc";
System.out.println(myString.toLowerCase() == "abc");
//--==>> false
```
양쪽 다 **`"abc"`** 이니까 **`true`** 가 나올 것 같은데, 실행하면 **`false`** 가 나옵니다. 기본형의 비교 연산자는 양쪽의 값이 같으면 **`true`** 가 나오는데요. **참조형의 비교 연산자는 가리키는 인스턴스가 같은 인스턴스인지 확인하는 역할을 합니다.** 위의 예시에서 두 인스턴스가 서로 다른 인스턴스이기 때문에 **`false`** 가 나오는 거죠. 만약 두 문자열의 **내용**이 같은지 비교하려면 **`==`** 가 아니라 **`equals`** 메소드를 사용하셔야 합니다.

```java
String myString = "Aaa"
System.out.println(myString.toUpperCase().equals("AAA"));
//--==>> true
```


# 2. 숫자 도구
'클래스 메소드' 노트에서 수학 관련 클래스인 **`Math`** 클래스를 보았었죠? 이번에는 **`Math`** 클래스와 더불어 **`Random`** 클래스를 살펴보겠습니다.

## **Math 클래스**
### **절댓값**
```java
import java.lang.Math;

public class Main {
	public class void main(String[] args) {
		System.out.println(Math.abs(-2));
		System.out.println(Math.abs(5));
	}
}
//--==>>
/*
2
5
*/
```

### **최솟값, 최댓값**
```java
import java.lang.Math;

public class Main{
	public static void main(String[] args) {
		System.out.println(Math.min(1, 10));  // 최솟값
		System.out.println(Math.max(1, 10));  // 최댓값
	}
}
//--==>>
/*
1
10
*/
```

## **Random 클래스**
임의의 값을 받아오기 위해서는 **`Random`** 클래스를 **`import`** 해야 합니다. 그런데 **`Math`** 와는 달리 **`Random`** 은 인스턴스를 생성해서 사용해야 합니다. **`0`** 이상 **`n`** 이하의 랜덤 값을 받아오려면 **`Random`** 클래스에 있는 **`nextInt`** 메소드를 사용
```java
import java.util.Random;

public class Main {
	public static void main(String[] args) {
		Random rand = new Random();
		System.out.println(rand.nextInt(10));  // 0이상 9이하의 랜덤한 값
	}
}
```

### **`a`와 `b` 사이의 랜덤 값**
```java
import java.util.Random;

public class Main {
	public static void main(String[] args) {
		Random rand = new Random();
		int min = 10;
		int max = 30;

		System.out.println(rand.nextInt((max - min) + 1) + min);
		// 10 이상 30 이하의 랜덤한 값
	}
}
```


# 3. Wrapper Class

'Wrapper 클래스'는 기본 자료형을 객체 형식으로 감싸는 역할
**`Integer`** 클래스는 **`int`** 형을, **`Double`** 클래스는 **`double`** 을, **`Long`** 클래스는 **`long`** 을, **`Boolean`** 클래스는 **`boolean`** 을 감싸는 것이다. 
기본형 자료형(Primitive Type)을 참조형(Reference Type)처럼 다루어야할 때 Wrapper 클래스를 사용하면 된다. 예를 들어서 **`ArrayList`** 같은 컬렉션을 사용할 때 꼭 참조형을 사용해야 한다. Wrapper 클래스의 인스턴스는 생성자로 생성할 수도 있고, 리터럴로 생성할 수도 있다.
```java
Integer i = new Integer(123);
Integer i = 123;
```
주의할 점이 있다.
```java
System.out.println(123 == 123);
//--==>> true
System.out.println(new Integer(123) == new Integer(123));
//--==>> false
```
첫 번째 줄의 결과값은 **`true`** 그런데 두 번째 줄은 **`false`**
참조형의 비교 연산자는 가리키는 객체가 같읕지 비교하기 때문
두 생성자를 통해 만든 다른 객체이기 때문에 **`false`** 가 나온다. 두 **`String`** 인스턴스를 비교할 때처럼 **`equals`** 메소드를 쓰면 '값'이 같은지 확인할 수 있다.
```java
System.out.println(new Integer(123).equals(new Integer(123)));
//--==>> true
```

# 4. ArrayList
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> nameList = new ArrayList<>();
        nameList.add("kim");

        System.out.println(nameList.size());
        //--==>> 1
        System.out.println(nameList.get(0));
        //--==>> kim

        nameList.add("lee");
        nameList.add("park");
        nameList.add("cho");

        nameList.remove(2);

        System.out.println(nameList.size());
        //--==>> 3
        System.out.println(nameList);
        //--==>> [kim, lee, cho]
    }
}
```

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
       ArrayList<Integer> numList = new ArrayList<>();
       // ArrayList에는 기본형을 넣을 수 없기 때문에 래퍼 클래스를 사용해야 한다.

        numList.add(1);
        numList.add(2);
        numList.add(3);
        numList.add(4);
        numList.add(5);

        for (int num : numList) {
            System.out.println(num * num);
        }
    }
}
//--==>>
/*
1
4
9
16
25
 */
```

# 5. 김신 장군 살리기
_전쟁에서 처참한 패배를 겪고 돌아온 김신 장군. 책임을 지기 위해 살아 돌아온 이들에게 자결을 제안하는데..._ **`n`** 명의 군사들이 동그랗게 서있고, 한 명씩 세어 나가서 매 **`k`** 번째 사람이 죽기로 합니다. 예를 들어서 8명의 군사들이 있고 3명마다 죽기로 하면 이 순서로 군사들이 죽게 됩니다.
```
3 => 6 => 1 => 5 => 2 => 8 => 4 => 7
```
하지만 야비한 김신 장군은 자신이 마지막으로 남아서 도망가려는 속셈인데요. 파라미터로 정수 **`n`** 과 정수 **`k`** 를 받고, 김신 장군이 살기 위해 서있어야할 자리(**`int`**)를 리턴해주는 메소드 **`getSurvivingIndex`** 를 쓰세요. **`ArrayList`를 사용하세요!**

### **템플릿**

```java
import java.util.ArrayList;

public class Main {
    public static int getSurvivingIndex(int n, int k) {
        // 코드를 입력하세요.
    }

    public static void main(String[] args) {
        System.out.println("김신은 " + getSurvivingIndex(20, 5) + "번 자리에 서있으면 됩니다.");
    }
}
```
```
5번 군사가 죽습니다.
10번 군사가 죽습니다.
15번 군사가 죽습니다.
20번 군사가 죽습니다.
6번 군사가 죽습니다.
12번 군사가 죽습니다.
18번 군사가 죽습니다.
4번 군사가 죽습니다.
13번 군사가 죽습니다.
1번 군사가 죽습니다.
9번 군사가 죽습니다.
19번 군사가 죽습니다.
11번 군사가 죽습니다.
3번 군사가 죽습니다.
17번 군사가 죽습니다.
16번 군사가 죽습니다.
2번 군사가 죽습니다.
8번 군사가 죽습니다.
14번 군사가 죽습니다.
김신은 7번 자리에 서있으면 됩니다.
```

## 해답
```java
import java.util.ArrayList;

public class Main {
    public static int getSurvivingIndex(int n, int k) {
        ArrayList<Integer> soldiers = new ArrayList<>();

        for (int soldierNumber = 1; soldierNumber <= n; soldierNumber++) {
			// soldiers.add(new Integer(soldierNumber));
            // 이 과정이 너무 복잡하니까
            // Java에서는 래퍼클래스(Wrapper class)가 필요한 위치에
            // 그것의 프리미티브 타입(Primitive Type)을 짚어 넣게 되면
            // 내부적으로 래퍼 클래스를 치환을 해 주게 된다.
            soldiers.add(soldierNumber);
        }

        int killIndex = 0;
        while (soldiers.size() > 1) {
            killIndex = (killIndex + k - 1) % soldiers.size();

            System.out.println(soldiers.remove(killIndex) + "번 군사가 죽습니다.");
        }

        return soldiers.get(0);
    }

    public static void main(String[] args) {
        System.out.println("김신은 " + getSurvivingIndex(20, 5) + "번 자리에 서있으면 됩니다.");
    }
}
```

# 6. HashMap
HashMap은 값을 지정하는 원소와 그 값을 가리키는 키를 같이 지정한다.
```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
		HashMap<Integer, String> dex = new HashMap<>();
		dex.put(1, "피카츄");
		dex.put(30, "라이츄");
		dex.put(20, "이상해풀");

        dex.remove(30);
        String a = dex.get(20);
        System.out.println(a);
        //--==>> 이상해풀

        dex.put(1, "피츄");
        System.out.println(dex.get(1));
        //--==>> 피츄

        // keySet 메소드는 HashMap의 키들이 담겨있는 리스트를 받아올 수 있다.
        for(int key : dex.keySet()){
            System.out.println(dex.get(key));
        }
        //--==>> 피츄 이상해풀
    }
}
```

# 7. HashMap 노트
**`HashMap`** 은 'value(원소)'와, 그 원소를 가리키는 'key' 값을 같이 저장한다. 순서만 있는 **`ArrayList`** 와 달리, key와 value가 쌍을 이루고 있다.

## **사용**
**`HashMap`** 의 키로는 **`String`** 을 쓰는 것이 가장 일반적
이름이나 'ID'를 담기에 **`String`** 이 가장 쉽고 직관적이기도 하고, **`HashMap`** 의 동작 원리상 **`String`** 이 적합하기도 한다.

### **선언하기**
선언과 인스턴스 생성은 **`ArrayList`** 와 매우 비슷, 꺽쇠 안에 key와 value의 자료형을 적어준다.
```java
HashMap<String, Pokemon> pokedex = new HashMap<>();
```

### **Key-Value 쌍 추가하기**
**`HashMap`** 에 쌍을 추가할 때는 **`put`** 메소드를 사용
첫 번째 파라미터로 key를 넘겨주고, 두 번째 파라미터로 value를 넘겨주면 된다.
```java
pokedex.put("피카츄", new Pokemon("피카츄"));
pokedex.put("이상해꽃", new Pokemon("이상해꽃"));
```

### **값 꺼내기**
원소를 꺼낼 때는 **`get`** 메소드를 사용
찾고자 하는 value에 해당하는 key를 파라미터로 넘겨주면 된다.
```java
Pokemon pikachu = pokedex.get("피카츄");
```

### **원소 덮어쓰기**
같은 key에 여러 value를 저장하면 가장 마지막에 저장된 value로 덮어 씌워진다.
```java
pokedex.put("피카츄", new Pokemon("라이츄");
```
이렇게 하면, 앞서 넣었던 '피카츄' 인스턴스는 이제 '라이츄' 인스턴스로 덮어지게 된다.

### **반복문을 통해 HashMap 탐색하기**
**`HashMap`** 의 **`keyset`** 메소드는 모든 key를 담고 있는 **`Set`** 을 리턴 
**`Set`** 은 **`List`** 나 **`Map`** 과 같이 원소를 담고 있는 자료형 중 하나이며 'for each'문으로 탐색이 가능
```java
for (String key : pokedex.keySet()) {
    System.out.println(pokedex.get(key));
}
```

## **(심화) HashMap의 동작 원리**
**`HashMap`** 의 key는 **'hashcode'** 라는 것으로 관리된다. 
hashcode는 모든 클래스의 인스턴스가 가진 고유한 값인데, 인스턴스마다 다르기 때문에 **`HashMap`** 이 key를 구분하는 값으로 사용된다(여러 인스턴스가 같은 hashcode를 가질 수 있으며, 이 경우 **`HashMap`** 에선 **`key.equals(anotherKey)`** 메소드로 구분). 일반적인 클래스는 인스턴스 생성시 hashcode 값이 결정된다. 즉, 같은 정보를 담고 있는 두 인스턴스가 서로 다른 hashcode를 가질 수 있다는 말이다. 그런데 **`String`** 은 서로 다른 인스턴스라도 안의 내용이 같으면 같은 hashcode를 갖습니다. 그렇기 때문에 **`HashMap`** 의 key로서 **`String`** 이 매우 적합하다. Key는 실제 인스턴스보다는 안에 담긴 의미, 내용으로 구분하는 것이 좋기 때문이다.

# 8. 나의 영어 사전
실리콘 밸리의 프로그래밍 트렌드에 뒤쳐지지 않기 위해서 영어 공부를 하려고 합니다. 영어 공부를 도와줄 단어장을 만들어 봅시다! **`Main`** 클래스만 주어집니다. **`Main`** 클래스를 보고 **`WordDictionary`** 클래스를 완성시켜 보세요! **대소문자 처리에 유의해주세요. 대소문자와 상관없이 단어를 찾을 수 있어야 합니다.**

### **결과**
```
책
안경
```
### 템플릿
Main.java
```java
public class Main {
    public static void main(String[] args) {
        WordDictionary dictionary = new WordDictionary();
        dictionary.addWord("Movie", "영화");
        dictionary.addWord("cat", "고양이");
        dictionary.addWord("Dog", "개");
        dictionary.addWord("book", "책");
        dictionary.addWord("soap", "비누");
        dictionary.addWord("Glasses", "안경");

        System.out.println(dictionary.find("Book"));
        System.out.println(dictionary.find("glasses"));
    }
}
```

WordDictionary.java
```java
public class WordDictionary { 
}
```

## 해답
### **설계**
**`WordDictionary`** 클래스를 설계해 봅시다.
```java
WordDictionary dictionary = new WordDictionary();
dictionary.addWord("Movie", "영화");
...
dictionary.addWord("book", "책");
System.out.println(dictionary.find("Book"));
System.out.println(dictionary.find("glasses"));
```

생성자는 별다른 파라미터가 없고, 메소드는 **`addWord(String, String)`** 와 **`find(String)`**, 이렇게 두 개가 있다.
```java
public class WordDictionary {
    public void addWord(String english, String korean) {

    }

    public String find(String english) {

    }
}
```

### **단어저장**
이제 그리고 가장 중요한 부분인 **단어를 어떻게 저장할지** 고민해 봐야 합니다. 역시 메인 메소드를 보니, 영어 단어 하나에 한글 단어 하나를 연결 하네요. **String key**하나에 **String 원소** 하나를 연결 하면 되니, 앞서 배운 **`HashMap`** 을 사용해 볼까요?
```java
public class WordDictionary {
    private HashMap<String, String> words = new HashMap<>();
    ...
}
```

### **메소드 구현**
**`add`** 메소드를 구현해 봅시다.
```java
public void addWord(String english, String korean) {
    words.put(english, korean);
}
```
파라미터로 받은 값들을 그대로 key와 원소로 사용해서 **`words`** 에 넣으면 됩니다. 
**`find`** 메소드도 구현해 봅시다! 두 가지를 고민해야합니다. 하나는 **`HashMap`** 탐색, 다른 하나는 대소문자처리 입니다. **`HashMap`** 탐색은 강의에서 보셨던 **`.keySet()`** 메소드를 통해서 구현할 수 있었습니다.
```java
public String find(String english) {
    for (String key : words.keySet()) {

    }
}
```
그리고 대소문자 구분 없이 검색이 되어야 하는데, String 강의에서 배운 **`.toLowerCase()`** 메소드를 쓰면 되겠죠!
```java
public String find(String english) {
    for (String key : words.keySet()) {
        if (key.toLowerCase().equals(english.toLowerCase())) {
            return words.get(key);
        }
    }

    return null;
}
```

중요한 점은 key와 파라미터 **`english`** 모두 **`.toLowerCase()`** 메소드를 사용해야합니다. 그리고 마지막으로, 탐색에 실패했을 경우 **`null`** 을 리턴해 주어, 이 메소드가 리턴 없이 끝나지 않도록 합니다.

## **모범 답안 (WordDictionary.java)**
```java
import java.util.HashMap;

public class WordDictionary {
    private HashMap<String, String> words = new HashMap<>();

    public void addWord(String english, String korean) {
        words.put(english, korean);
    }

    public String find(String english) {
        for (String key : words.keySet()) {
            if (key.toLowerCase().equals(english.toLowerCase())) {
                return words.get(key);
            }
        }

        return null;
    }
}
```

# 9. 포겟몬
산책하며 포켓몬을 많이 잡았습니다. `HashMap`과 `ArrayList`를 활용하여 포켓몬들을 담을 가방을 만들어 봅시다!

### PokeBag 클래스
(1) `private final 자료형 pokemons = new 자료형();`
`HashMap` 강의에서 만들었던 `PokeDex`에서는 한 마리의 마릴 인스턴스만 담을 수 있었죠? `PokeBag`에서는 마릴이라는 key 하나에 여러 마리의 마릴 인스턴스를 담을 수 있습니다.
이 상황에 적합한 자료형을 생각해 봅시다.

(2) `public ArrayList<Pokemon> getPokemons(String name)`
`name` 이름을 갖고 있는 포켓몬을 모두 가져오는 메소드입니다.

(3) `public void add(Pokemon pokemon)`
과정 (1)에서 구현한 `pokemons`에 `Pokemon`을 넣는 메소드입니다.

(4) `public Pokemon getStrongest(String name)`
`name` 이름의 포켓몬 중 가장 강한(cp가 가장 큰) 포켓몬을 가져오는 메소드입니다.

(5) `public Pokemon getStrongest()`
내가 가진 모든 포켓몬 중 가장 강한 포켓몬을 가져오는 메소드입니다. 내부적으로 (4)번 메소드를 호출하도록 구현해보세요.

### 템플릿
### Main.java
```java
public class Main {
    public static void main(String[] args) {
        PokeBag pokeBag = new PokeBag();

        pokeBag.add(new Pokemon("마그마", 1024));
        pokeBag.add(new Pokemon("마그마그", 215));
        pokeBag.add(new Pokemon("마릴", 816));
        pokeBag.add(new Pokemon("마그마그", 136));
        pokeBag.add(new Pokemon("라프라스", 1822));
        pokeBag.add(new Pokemon("마릴", 215));
        pokeBag.add(new Pokemon("마릴", 185));
        pokeBag.add(new Pokemon("마릴", 110));
        pokeBag.add(new Pokemon("니드킹", 1709));
        pokeBag.add(new Pokemon("마릴", 39));
        pokeBag.add(new Pokemon("마자용", 12));

        System.out.println(pokeBag.getStrongest("마릴"));
        System.out.println(pokeBag.getStrongest());
        System.out.println(pokeBag.getStrongest("피카츄"));
    }
}
```
### Pokemon.java
```java
public class Pokemon {
    public final String name;
    public final int cp;

    public Pokemon(String name, int cp) {
        this.name = name;
        this.cp = cp;
    }

    @Override
    public String toString() {
        return name + "(" + cp + ")";
    }
}
```
### PokeBag.java
```java
import java.util.ArrayList;

public class PokeBag {
    private final 자료형 pokemons = new 자료형();

    public ArrayList<Pokemon> getPokemons(String name) {
    }

    public void add(Pokemon pokemon) {
    }

    public Pokemon getStrongest(String name) {
    }

    public Pokemon getStrongest() {
    }
}
```
### 출력값
```
마릴(816)
라프라스(1822)
null
```

## 해답

### **PokeBag 클래스**

### **pokemons 변수**

**`HashMap<String, Pokemon>`** 은 key와 value가 1:1 대응이었죠? 그런데 우리가 하고자 하는 것은 'key 하나에 여러 마리의 포켓몬을 넣는 것'이기 때문에 이 구조는 사용할 수 없습니다. 대신 key에 대응하는 value를 **`ArrayList<Pokemon>`** 으로 해서 그 **`ArrayList`** 가 여러 마리의 포켓몬을 들게 할 수 있겠죠?

```java
private final HashMap<String, ArrayList<Pokemon>> pokemons = new HashMap<>();
```

### **public ArrayList\<Pokemon\> getPokemons(String name) 메소드**
name 이라는 이름의 포켓몬을 모두 가져오는 메소드입니다. 아주 간단합니다.
```java
public ArrayList<Pokemon> getPokemons(String name) {
    return pokemons.get(name);
}
```

### **public void add(Pokemon pokemon) 메소드**
**pokemons** 에 **Pokemon** 인스턴스를 넣는 메소드입니다. 일단 사용하기 편하게 새 포켓몬의 이름을 저장해두겠습니다.
```java
String name = pokemon.name;
```
넣을 때 두 가지 경우가 있을 수 있습니다:
1.  **이미 같은 이름의 포켓몬이 존재하는 경우**
2.  **완전히 새로운 포켓몬인 경우**
이미 같은 이름의 포켓몬이 존재하는 경우에는 **`name`** key에 해당하는 **`ArrayList`** 에 **`pokemon`** 을 추가해주면 됩니다.
```java
getPokemons(name).add(pokemon);
```
하지만 완전히 새로운 포켓몬인 경우에는 먼저 **`ArrayList`** 를 만들어줘야겠죠?
```java
public void add(Pokemon pokemon) {
    String name = pokemon.name;

    // 해당하는 ArrayList가 없으면 생성
    if (getPokemons(name) == null) {
        pokemons.put(name, new ArrayList<Pokemon>());
    }

    getPokemons(name).add(pokemon);
}
```

### **public Pokemon getStrongest(String name) 메소드**
**`name`** 이라는 이름의 포켓몬 중 가장 강한(cp가 가장 큰) 포켓몬을 가져오는 메소드입니다. 먼저 **`name`** key에 해당하는 **`ArrayList`** 를 탐색해야겠죠?
```java
// name 이름의 포켓몬 목록
ArrayList<Pokemon> pokemonList = getPokemons(name);
```
그런데 **`getPokemons("asdwqe")`** 처럼 존재하지 않는 이름을 넣으면 **`null`** 이 나옵니다. 그런 경우 그냥 **`null`** 을 리턴해주면 됩니다!
```java
if (pokemonList == null) {
    return null;
}
```
**`null`** 이 아닌 경우 가장 강한 포켓몬을 찾아 리턴시켜주면 되겠죠?
```java
// return할 포켓몬(가장 센 포켓몬)을 담을 변수.
Pokemon strongest = null;

// name에 해당하는 ArrayList를 가져오고 탐색
for (Pokemon pokemon : pokemonList) {
    // 비교를 통해 strongest를 찾음
}

return strongest;
```
이제 반복문 안에서 **`strongest`** 를 찾는 부분만 채워 넣으면 되는데요. **`cp`** 가 더 큰 포켓몬이 나타나면 대체해주면 됩니다.
```java
if (pokemon.cp > strongest.cp) {
    strongest = pokemon;
}
```

그런데 위처럼 쓰면 처음에 **`strongest`** 가 **`null`** 인 경우에 오류가 나옵니다. **`strongest.cp`** 가 문제를 일으키기 때문이죠. **`strongest`** 가 **`null`** 인 경우에는 그냥 **`pokemon`** 을 **`strongest`** 에 지정해주면 되겠죠?

숏서킷 연산을 생각하면 깔끔하게 작성할 수 있습니다.
```java
if (strongest == null || pokemon.cp > strongest.cp) {
    strongest = pokemon;
}
```
완성된 메소드입니다.
```java
public Pokemon getStrongest(String name) {
    // name 이름의 포켓몬 목록
    ArrayList<Pokemon> pokemonList = getPokemons(name);

    if (pokemonList == null) {
        return null;
    }

    // return할 포켓몬(가장 센 포켓몬)을 담을 변수.
    Pokemon strongest = null;

    for (Pokemon pokemon : getPokemons(name)) {
        if (strongest == null || pokemon.cp > strongest.cp) {
            strongest = pokemon;
        }
    }

    return strongest;
}
```

### **public Pokemon getStrongest() 메소드**
가진 **모든** 포켓몬 중 가장 강한 포켓몬을 가져오는 메소드입니다.
위 메소드와 비슷하지만 **`HashMap`** 에서 모든 key에 해당하는 **`ArrayList`** 를 확인해야 한다는 점이 다릅니다.
```java
// return할 포켓몬(가장 센 포켓몬)을 담을 변수.
Pokemon strongest = null;

for (String key : pokemons.keySet()) {
    // key에 해당하는 가장 센 포켓몬을 가져오기
    Pokemon p = getStrongest(key);

    // strongest를 가장 센 포켓몬으로 교체
}
```
완성된 메소드입니다.
```java
public Pokemon getStrongest() {
    // return할 포켓몬(가장 센 포켓몬)을 담을 변수.
    Pokemon strongest = null;

    // HashMap 전체를 탐색 (keySet을 통해 얻은 key로 탐색)
    for (String key : pokemons.keySet()) {
        // key에 해당하는 가장 센 포켓몬을 가져오기
        Pokemon p = getStrongest(key);

        // strongest를 가장 센 포켓몬으로 교체
        if (strongest == null || p.cp > strongest.cp) {
            strongest = p;
        }
    }

    return strongest;
}
```

### **모범 답안 (`PokeBag.java`)**

```java
import java.util.ArrayList;
import java.util.HashMap;

public class PokeBag {

    private final HashMap<String, ArrayList<Pokemon>> pokemons = new HashMap<>();

    public ArrayList<Pokemon> getPokemons(String name) {
        return pokemons.get(name);
    }

    public void add(Pokemon pokemon) {
        String name = pokemon.name;

        // 해당하는 ArrayList가 없으면 생성
        if (getPokemons(name) == null) {
            pokemons.put(name, new ArrayList<Pokemon>());
        }

        getPokemons(name).add(pokemon);
    }

    public Pokemon getStrongest(String name) {
        // name 이름의 포켓몬 목록
        ArrayList<Pokemon> pokemonList = getPokemons(name);

        if (pokemonList == null) {
            return null;
        }

        // return할 포켓몬(가장 센 포켓몬)을 담을 변수.
        Pokemon strongest = null;

        for (Pokemon pokemon : getPokemons(name)) {
            if (strongest == null || pokemon.cp > strongest.cp) {
                strongest = pokemon;
            }
        }

        return strongest;
    }

    public Pokemon getStrongest() {
        // return할 포켓몬(가장 센 포켓몬)을 담을 변수.
        Pokemon strongest = null;

        // HashMap 전체를 탐색 (keySet을 통해 얻은 key로 탐색)
        for (String key : pokemons.keySet()) {
            // key에 해당하는 가장 센 포켓몬을 가져오기
            Pokemon p = getStrongest(key);

            // strongest를 가장 센 포켓몬으로 교체
            if (strongest == null || p.cp > strongest.cp) {
                strongest = p;
            }
        }

        return strongest;
    }
}
```