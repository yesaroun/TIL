
# 2. 접근 제어자 정리

Person.java
```java
public class Person {
	int age;
}
```

Driver.java
```java
public class Driver {
	public static void main(String[] args) {
		Person p1 = new Person();
		p1.age = 28;
		System.out.println(p1.age);
	}
}
```

사실 이건 굉장히 위헌한 코드입니다. p1.age = 28;을 p1.age = 10;으로 바꾸어도 아무런 문제가 없이 실행됩니다. 나이가 음수인건 말이 안되는데 말입니다.


## 접근 제어자
이처럼 객체에 대한 권한을 너무 쉽게 주면 문제가 생길 수 있습니다. 다행히 자바에서는 권한을 제한해주는 ‘접근 제어자(Access Modifier)’라는 게 있습니다.

Person.java
```java
public class Person {
    private int age;
}
```
인스턴스 변수 앞에 private이라는 접근 제어자를 써주면 그 변수는 해당 클래스 내에서만 접근 가능합니다. 이제 Driver는 age에 대한 권한이 없기 때문에 Driver에서 **`p1.age = -10;`** 을 해주려고 하면 오류가 나올 것입니다. 마찬가지로 **`System.out.println(p1.age);`** 도 불가능합니다. 그러면 이제는 **`age`** 에 대한 권한이 아예 없는 걸까요? 아닙니다! **`private`** 변수라도 그 클래스 내에서는 사용이 가능하기 때문에, 그 클래스에 **`age`** 를 사용하는 메소드를 쓰면 됩니다.

### **Person.java**
```java
public class Person {
    private int age;

    public void setAge(int newAge) {
        if (newAge > 0) {
            age = newAge;
        }
    }

    public int getAge() {
        return age;
    }
}
```
이제 **`setAge`** 와 **`getAge`** 메소드를 이용해서 **`age`** 변수를 바꿔주고 받아올 수 있습니다. **`setAge`** 와 **`getAge`** 같은 메소드를 흔히 'setter' 메소드와 'getter' 메소드라고 부릅니다. 그런데 보시면 두 메소드 앞에는 **`public`** 이라는 접근 제어자를 써주었죠? 변수 **`age`** 는 숨기고 싶어서 **`private`** 으로 설정했지만, **`setAge`** 와 **`getAge`** 는 다른 클래스에서도 사용하고 싶기 때문에 어디서든 접근 가능하게 해주는 **`public`** 을 썼습니다. 이제 드라이버를 이렇게 바꿀 수 있습니다:
## **Driver.java**
```java
public class Driver {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.setAge(28);
        p1.setAge(-10);
        System.out.println(p1.getAge());
    }
}
//--==>> 28
```


# 5. 메소드 오버로딩 정리
'메소드 오버로딩(Method Overloading)'은 클래스 내에 같은 이름의 메소드를 2개 이상 정의할 수 있게 해주는 기능입니다.

```java
public class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        Calculator c = new Calculator();

        System.out.println(c.add(3, 5));
        System.out.println(c.add(4, 8, 12));
        System.out.println(c.add(1.5, 2.5));
    }
}
//--==>>
/*
8
24
4.0
 */
```
**`add`** 라는 이름의 메소드가 세 개나 있죠? 그런데 아무 오류도 나지 않습니다. 왜 그럴까요? 잘 보시면 각 메소드는 다른 구성의 파라미터들을 받습니다. 첫 번째 **`add`** 는 정수형 값 두 개, 두 번째 **`add`** 는 정수형 값 세 개, 그리고 세 번째 **`add`** 는 소수형 값 두 개를 받습니다. 같은 이름의 메소드라도 파라미터 구성이 다르면 자바는 알아서 구분을 할 수 있습니다. **`main`** 메소드에서 **`c.add(2, 4)`** 를 하면 알아서 첫 번째 **`add`** 가 불리고, **`c.add(2, 4, 8)`** 을 하면 두 번째 **`add`** 가 불리고, **`c.add(3.14, 2.54)`** 를 하면 세 번째 **`add`** 가 불리는 거죠.

## **쓰임 (Usage)**

### **은행 계좌 예제**
'달러'나 '유로'같은 다른 통화로 입금을 하는 **`depositWithExchangeRate`** 메소드를 아래처럼 쓸 수 있습니다.
```java
public boolean deposit(int amount) {
    if (amount < 0 || amount > owner.getCashAmount()) {
        System.out.println("입금 실패입니다. 잔고: " + balance + "원, 현금: " + owner.getCashAmount() + "원");
        return false;
    }

    balance += amount;
    owner.setCashAmount(owner.getCashAmount() - amount);

    System.out.println(amount + "원 입금하였습니다. 잔고: " + balance + "원, 현금: " + owner.getCashAmount() + "원");
    return true;
}

public boolean depositWithExchangeRate(double amount, double exchangeRate) {
    return deposit((int) (amount * exchangeRate));
}
```
하지만 사실 **`depositWithExchangeRate`** 을 **`deposit`** 으로 바꿔도 아무 문제 없습니다. 파라미터 구성이 달라 '메소드 오버로딩' 개념이 적용되기 때문이죠!
```java
public boolean deposit(double amount, double exchangeRate) {
    return deposit((int) (amount * exchangeRate));
}
```

### **콘솔 출력**
생각해보면 지금까지 써왔던 **`System.out.println`** 도 파라미터를 굉장히 다양하게 받죠? 이게 다 '메소드 오버로딩'입니다.
```java
System.out.println(5);        // 정수 파라미터
System.out.println(3.14);     // 소수 파라미터
System.out.println("hello");  // 문자열 파라미터
System.out.println(true);     // 불린 파라미터
//--==>>
/*
5
3.14
hello
true
*/
```


# 8. 생성자 정리

'생성자(Constructor)'는 크게 두 가지 역할이 있습니다:
1.  인스턴스를 만들고,
2.  인스턴스의 속성(인스턴스 변수)들을 초기화시켜줍니다.

## **기본 생성자**
생성자를 한 개도 정의 안 했을 경우에는 자바에서 자동으로 기본 생성자를 제공해줍니다. 우리도 사용했었죠?
```java
Person p1 = new Person();
```

### **생성자 정의**
생성자를 하나라도 정의하면 위의 기본 생성자는 사용할 수 없습니다.
```java
public class Person {
    String name;
    int age;

    public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
    }
}
```

파라미터 두 개를 받는 생성자를 작성했습니다. 그러면 원래는 이렇게 썼던 것을:
```java
public static void main(String[] args) {
    Person p1 = new Person();
    p1.setName("김신의");
    p1.setAge(27);
}
```
이렇게 바꿀 수 있습니다:
```java
public static void main(String[] args) {
    Person p1 = new Person("김신의", 27);
}
```

그러면 **`Person`** 인스턴스가 생성되고, 그 인스턴스의 변수 **`name`** 에 **`"김신의"`** 가 지정되고, 변수 **`age`** 에 **`27`** 이 지정됩니다. 한번에 모든 인스턴스 변수의 초기값을 설정할 수 있게 된 것이죠!

## **오버로딩**

파라미터의 구성을 다르게 하면 같은 이름의 메소드를 여러 개 정의할 수 있죠? 이 개념을 '메소드 오버로딩'이라고 했었는데요. 마찬가지로 생성자 오버로딩도 가능합니다.
```java
public Person(String pName, int pAge) {
    name = pName;
    age = pAge;
}

public Person(String pName) {
    name = pName;
    age = 12;    // 12살을 기본 나이로 설정
}
```

파라미터 하나만 받는 생성자도 작성했습니다. 그러면 어떤 파라미터를 넘기느냐에 따라 어떤 생성자가 사용될지 정해집니다.
```java
public static void main(String[] args) {
    Person p1 = new Person("김신의", 27);  // 첫 번째 생성자
    Person p2 = new Person("박윤석");      // 두 번째 생성자

    System.out.println(p1.name);
    System.out.println(p1.age);
    System.out.println(p2.name);
    System.out.println(p2.age);
}
//--==>>
/*
김신의
27
박윤석
12
*/
```

# 11. this 정리

자바에서 **`this`** 는 무언가를 가리키는 역할을 합니다! **`this`** 는 메소드에서 현재 인스턴스를 가리키는 역할을 합니다.
```java
class Person {
    private String name;

    public Person(String pName) {
        name = pName;
    }

    public void sayHello() {
        System.out.println("Hi. My name is " + this.name);
    }
}
```

```java
class Main {
    public static void main(String[] args) {
        Person p1 = new Person("김신의");
        p1.sayHello();

        Person p2 = new Person("강영훈");
        p2.sayHello();
    }
}
//--==>>
/*
Hi. My name is 김신의
Hi. My name is 강영훈
*/
```
**`p1.sayHello();`** 는 **`sayHello`** 메소드를 호출하죠? **`sayHello`** 메소드가 실행될 때 **`this`** 는 현재 인스턴스인 **`p1`** 입니다. **`p1.name`** 은 **`"김신의"`** 이기 때문에 위와 같은 출력값이 나옵니다.
마찬가지로 **`p2.sayHello();`** 를 하면 **`this`** 는 현재 인스턴스인 **`p2`** 를 가리킵니다.
그럼 이제 **`this`** 를 다양하게 활용해봅시다.

## **일반 메소드에서의 사용**

우리가 작성한 **`Person`** 클래스의 **`setName`** 메소드 입니다.
```java
public class Person {
    private String name;
    ...

    public void setName(String pName) {
        name = pName;
    }
    ...
}
```
이 메소드는 **`Person`** 클래스 내부에 있습니다. 그런데 만약 파라미터의 이름을 **`name`** 으로 바꾸면 어떻게 될까요?
```java
public class Person {
    private String name;
    ...

    public void setName(String name) {
        name = name;
    }
    ...
}
```
**`name = name;`** 이라는 애매한 코드가 생기게 됩니다. **두 `name`은 서로 같은 변수이며, 클래스의 인스턴스 변수가 아닌 파라미터를 가리키게 됩니다.** 해당 위치(**`setName`** 메소드)에서 인스턴스 변수 **`name`** 보다 파라미터 변수 **`name`** 이 더 가깝기 때문이죠!

이런 상황에서, 이 클래스로 생성된 인스턴스 변수 **`name`** 을 가리키고 싶다면? 아래처럼 **`this`** 을 사용하면 됩니다!
```java
public void setName(String name) {
    this.name = name;
}
```

이제 클래스의 인스턴스 변수 **`name`** 과 파라미터 변수 **`name`** 이 확실하게 구분되죠?

## **생성자에서의 사용**

생성자에서도 동일하게 적용 가능합니다.
**`BankAccount`** 의 생성자를 보겠습니다.
```java
public class BankAcount {
    private Person owner;
    ...

    public BankAccount(Person pOwner) {
        owner = pOwner;
    }
    ...
}
```
여기서도 **`this`** 를 사용할 수 있습니다.
```java
public BankAccount(Person owner) {
    this.owner = owner;
}
```
파라미터로 **`owner`** 인스턴스를 받고, 바로 **`BankAccount`** 의 인스턴스 변수에 넣어주었습니다.
그렇다면 **`BankAccount`** 의 인스턴스를 **`Person`** 의 인스턴스에 넣어주는 것은 어떻게 할 수 있을까요?

원래는 이렇게 했었는데,
```java
// 은행 계좌 생성
BankAccount a1 = new BankAccount(p1);
a1.setBalance(10000);

p1.setAccount(a1); // 이 부분은 어떻게 처리할까요?
// a1.setOwner(p1); 생성자에서 처리하였음.
```
**`this`** 키워드를 사용하면 이렇게 바꿀 수 있습니다.
```java
public class BankAccount {
    // 생성자
    public BankAccount(Person owner) {
        this.owner = owner;
        owner.setAccount(this);
    }
}
```

## **생성자로서의 사용**
생성자에서 **`this`** 의 중요한 역할이 또 있습니다! **`this`** 는 현재 클래스의 생성자로 사용할 수도 있습니다. 
이렇게 생성자가 여러 개 있다고 가정합시다.
```java
public Person(String name) {
    this.name = name
    age = 12;
    cashAmount = 0;
}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
    cashAmount = 0;
}

public Person(String name, int age, int cashAmount) {
    if (age < 0) {
        this.age = 12;
    } else {
        this.age = age;
    }

    if (cashAmount < 0) {
        this.cashAmount = 0;
    } else {
        this.cashAmount = cashAmount;
    }
    this.name = name;
}
```
**`this`** 를 사용하면 훨씬 깔끔하게 작성할 수 있습니다.
```java
public Person(String name) {
    this(name, 12, 0); // 12살을 기본 나이로 설정, 초기 현금 보유액은 0원.
}

public Person(String name, int age) {
    this(name, age, 0); // 초기 현금 보유액은 0원.
}

public Person(String name, int age, int cashAmount) {
    if (age < 0) {
        this.age = 12;
    } else {
        this.age = age;
    }

    if (cashAmount < 0) {
        this.cashAmount = 0;
    } else {
        this.cashAmount = cashAmount;
    }
    this.name = name;
}
```
첫 번째 경우의 **`this(name, 12, 0);`** 은 세 번째 생성자 **`Person(name, 12, 0);`** 에 각각의 파라미터를 넘겨 호출하는 것과 같다고 생각할 수 있고, 두 번째 경우의 **`this(name, age, 0);`** 은 **`Person(name, age, 0);`** 에 파라미터를 넘겨 호출하는것과 같다고 생각할 수 있습니다.
이렇게 파라미터가 가장 많은 생성자를 파라미터가 적은 쪽에서 호출 하는 것이 가장 효율적입니다!