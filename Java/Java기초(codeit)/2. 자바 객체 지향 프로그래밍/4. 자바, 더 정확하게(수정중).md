
# 2. ***기본형 vs. 참조형 정리***

자바의 변수에는 두 가지 종류가 있다. 
하나는 '기본형(Primitive Type)', 그리고 
다른 하나는 '참조형(Reference Type)'이다. 
**`int`**, **`boolean`**, **`char`**, **`double`** 등은 모두 기본형이고, 
**`Person`**, **`String`**, **`int[]`** 등 클래스 기반 자료형은 모두 참조형입니다.

## **기본형 (Primitive Type)**
기본형의 경우에는 변수가 값 자체를 보관한다고 생각하면 된다.

## **참조형 (Reference Type)**
참조형의 경우에는 변수가 값 자체를 보관하는 게 아니라, 변수가 값을 '가리킨다'고 생각하시면 된다. 실제 값은 메모리의 어딘가에 저장되어 있고, 변수는 그 영역을 가리키는 역할인 셈이다.

### **객체**
```java
Person p1, p2;
p1 = new Person("kim", 28);

p2 = p1;
p2.setName("lee");

System.out.println(p1.getName());
//--==>> lee
System.out.println(p2.getName());
//--==>> lee
```
**`p1`** 은 **`"kim"`** 라는 이름을 가진 **`Person`** 인스턴스가 저장되어 있는 영역을 가리킨다. **`p2 = p1`** 은 **`p2`** 에게 같은 영역을 가리키라는 명령이다. 그 후, **`p2.setName("lee")`** 를 하면 그 영역에 있는 인스턴스의 **`name`** 은 **`"lee"`** 로 바뀐다. **`p1`**, **`p2`** 모두 같은 영역을 가리키고 있으니까 두 출력 값은 모두 **`"lee"`** 이다.

### **배열**
자바에서 배열도 객체이기 때문에 참조형이다.
```java
int[] a = new int[3];
int[] b = a;

a[0] = 1;
b[0] = 2;

System.out.println(a[0]);
//--==>> 2
System.out.println(b[0]);
//--==>> 2
```


# 3. null

자바에서 실수로 발생하는 대표적인 에러 중 하나를 살펴보겠다. 어떤 언어들에서는 '비어있음'을 **`None`** 으로 표현하고, 또 어떤 언어들에서는 **`nil`** 로 표현한다. 자바에서는 '비어있음'이 **`null`** 이라는 값으로 표현된다. **단, `null`은 참조형 변수(Reference Type)만 가질 수 있는 값이다!**

```java
Person p1 = null;
System.out.println(p1);
//--==>> null
```

만약 **`null`** 을 보관하고 있는 변수의 메소드를 호출하려고 하면 **`NullPointerException`** 이라는 오류가 난다.
```java
Person p1 = null;
p1.getName();
//--==>> Exception in thread "main" java.lang.NullPointerException
```

## **대처법**

아래 코드는 오류가 날 것이다. **`people[1]`** 과 **`people[4]`** 는 **`null`** 이기 때문에 **`p.getName()`** 을 할 수가 없는 거다.
```java
Person[] people = new Person[5];
people[0] = new Person("kim", 28);
people[2] = new Person("lee", 26);
people[3] = new Person("park", 21);

for (int i = 0; i < people.length; i++) {
    Person p = people[i];
    System.out.println(p.getName());
}
```

이 문제를 해결하기 위해서는 **`p`** 가 **`null`** 인지 먼저 확인을 해주면 된다.
```java
Person[] people = new Person[5];
people[0] = new Person("kim", 28);
people[2] = new Person("lee", 26);
people[3] = new Person("park", 21);

for (int i = 0; i < people.length; i++) {
    Person p = people[i];
    if (p != null) {
        System.out.println(p.getName());
    } else {
        System.out.println(i + "번 자리는 비었습니다.");
    }
}
```

```
kim
1번 자리는 비었습니다.
lee
park
4번 자리는 비었습니다.
```

# ***4. 숏서킷 연산 (Short-Circuit Evaluation)***

## **And 연산 (&&)**
```java
boolean newBoolean = m1() && m2() && m3();
```

**`newBoolean`** 이 **`true`** 가 되기 위해서는 **`m1()`**, **`m2()`**, **`m3()`** 가 모두 **`true`** 를 리턴해야 한다. 
따라서 **`m1()`** 이 **`false`** 를 리턴하면 **`m2()`** 와 **`m3()`** 의 결과와 상관 없이 **`newBoolean`** 은 **`false`** 이다. 실제로 자바는 효율성을 위해서 **`m1()`** 이 **`false`** 를 리턴하면 **`m2()`** 와 **`m3()`** 를 실행하지 않는다. 
이렇게 식의 결과값이 이미 결정된 경우 미리 멈추는 것을 **'숏서킷 연산(Short-circuit evaluation)'** 이라고 한다. 만약 **`m1()`** 이 **`true`** 를 리턴하는데, **`m2()`** 가 **`false`** 를 리턴하면 **`m3()`** 는 실행되지 않는다.

# **Or 연산 (||)**
Or 연산(**`||`**)도 비슷하게 동작한다.
```java
boolean newBoolean = m1() || m2() || m3();
```
**`newBoolean`** 이 **`false`** 이기 위해서는 **`m1()`**, **`m2()`**, **`m3()`** 의 리턴값이 모두 **`false`** 이어야 한다. 따라서 **`m1()`** 이 **`true`** 를 리턴하면 **`m2()`** 와 **`m3()`** 는 실행되지 않고 **`newBoolean`** 은 **`true`** 가 된다.





































# **7. 변수 안전하게 만들기 (final)***

이번 시간에는 **`final`** 키워드에 대해서 배워보겠습니다. 변수를 정의할 때 **`final`** 을 써주면, 그 변수는 '상수'가 됩니다. 즉, 한 번 정의하고 나서 다시 바꿀 수 없다는 것이죠. 사용 방법이 경우에 따라 미세하게 다르니, 각 상황을 예시를 통해 봅시다.

## **기본형**

```java
final double pi = 3.141592;
pi = 2.54;
```

이 코드는 오류가 나옵니다. **`final`** 로 정의된 변수의 값을 바꿀 수 없기 때문이죠. **`π`**(**`pi`**)처럼 바꾸지 않는, 바꾸지 말아야 할 값이 있으면 **`final`** 을 써주시면 됩니다.

## **참조형**

```java
public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public static void main(String[] args) {
        final Person p1 = new Person("김신의");
        p1.setName("문종모");
        System.out.println(p1.getName());
    }
}
```

```
문종모
```

이 코드는 문제 없이 실행됩니다. **`p1`** 을 **`final`** 로 정의했는데 왜 그럴까요? **`final`** 은 **`p1`** 에 해당하는 것이지, **`p1`** 의 인스턴스 변수에 해당하는 것이 아니기 때문입니다. 따라서 **`p1`** 의 이름을 못 바꾸도록 만들고 싶으면 **`Person`** 클래스 내에서 **`name`** 을 **`final`** 로 정의해주면 됩니다.

```java
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public static void main(String[] args) {
        final Person p1 = new Person("김신의");
        p1.setName("문종모");
        System.out.println(p1.getName());
    }
}
```

```
java: cannot assign a value to final variable name
```

이제 오류가 나옵니다. **`final`** 변수는 한번만 설정해줄 수 있다고 했죠? 처음에 생성자에서 인스턴스 변수 **`name`** 을 설정해줬는데, **`setName`** 메소드에서 바꿔주려고 하니까 문제가 생기는 것이죠.

## **예제**

우리도 사실 객체에 해당하는 **`final`** 변수를 본적이 있습니다. 배열의 **`length`** 변수 기억하시나요?

```java
int[] numberList = new int[7];
System.out.println(numberList.length);
```

```
7
```

**`length`** 는 사실 **`final`** 변수입니다. 처음에 배열의 크기가 주어질 때 값이 정해지고, 그 후에는 바꿀 수 없다는 거죠.

```java
int[] numberList = new int[7];
numberList.length = 10;
```

이렇게 새로운 값을 지정해주려고 하면 오류 메시지가 나옵니다:

```
cannot assign a value to final variable length
```

**`length`** 가 **`final`** 변수이고, 따라서 값을 바꿀 수 없다는 뜻입니다.

# 10. 인스턴스 변수 vs 클래스 변수

## **클래스 변수란?**

지금까지는 인스턴스에 해당되는 '인스턴스 변수'와 '인스턴스 메소드'를 사용했습니다.

```java
Person p1 = new Person("문종모", 25, 50000);
BankAccount a1 = new BankAccount(100000);

a1.setOwner(p1);      // a1에 대한 인스턴스 메소드
a1.withdraw(20000);   // a1에 대한 인스턴스 메소드
```

하지만 인스턴스에 해당되지 않고, **클래스에 해당되는 '클래스 변수'** 도 존재합니다. 이 둘의 차이점을 정확히 이해해야, 좋은 객체 지향 코드를 작성할 수 있습니다. '클래스 변수'가 무엇인지, '인스턴스 변수'와는 어떻게 다른지, 같은 기능을 두 가지 방식으로 구현해 보면서 알아봅시다!

## **인스턴스 변수 버전**

현재는 **`Person`** 클래스에 **`count`** 라는 인스턴스 변수가 있습니다. **`count`** 는 현재 총 몇 개의 **`Person`** 인스턴스가 있는지 보관합니다.

```java
public class Person {
    int count;
}
```

그런데 새로운 **`Person`** 인스턴스를 생성할 때마다 각 인스턴스의 **`count`** 변수를 바꿔줘야 하죠? 굉장히 번거롭습니다.

```java
public static void main(String[] args) {
    Person p1 = new Person();
    p1.count++;

    Person p2 = new Person();
    p1.count++;
    p2.count = p1.count;

    Person p3 = new Person();
    p1.count++;
    p2.count++;
    p3.count = p2.count;

    Person p4 = new Person();
    p1.count++;
    p2.count++;
    p3.count++;
    p4.count = p3.count;

    System.out.println(p1.count);
    System.out.println(p2.count);
    System.out.println(p3.count);
    System.out.println(p4.count);
}
```

```
4
4
4
4
```

## **클래스 변수 버전**

이런 문제를 해결할 수 있는 게 바로 클래스 변수입니다. 클래스 변수를 정의하기 위해서는 **`static`** 이라는 키워드를 붙여주면 됩니다.

```java
public class Person {
    static int count;
}
```

이제 **`count`** 는 특정 인스턴스에 해당되는 게 아니라, **`Person`** 클래스 전체에 해당되는 것입니다. 따라서 **`count`** 를 부를 때는 대문자로 쓴 클래스 이름을 사용해서 **`Person.count`** 를 써주면 됩니다.

```java
public static void main(String[] args) {
    Person p1 = new Person();
    Person.count++;

    Person p2 = new Person();
    Person.count++;

    Person p3 = new Person();
    Person.count++;

    Person p4 = new Person();
    Person.count++;

    System.out.println(Person.count);
}
```

```
4
```

많이 깔끔해졌죠? 그런데 아직도 반복적인 코드가 많습니다. **`Person.count++`** 를 매번 해줘야 한다는 것인데요. 반복적인 코드는 안 좋은 것이기 때문에 개선시킬 방법이 필요하겠죠? 우리는 지금 새로운 인스턴스를 생성할 때마다 **`Person.count`** 를 **`1`** 씩 늘려주고 있죠? 그러면 아예 생성자에 이 줄을 넣으면 되겠군요!

```java
public class Person {
    static int count;

    public Person() {
        count++;
    }
}
```

```java
public static void main(String[] args) {
    Person p1 = new Person();
    Person p2 = new Person();
    Person p3 = new Person();
    Person p4 = new Person();

    System.out.println(Person.count);
}
```

```
4
```

훨씬 깔끔해졌습니다! 이런 식으로 변수가 클래스 자체에 해당될 때에는 **`static`** 을 써서 클래스 변수로 만들어주면 되겠죠? 이제 '인스턴스 변수'와 '클래스 변수'의 차이가 이해 되시나요?

## **상수**

우리가 자주 접하게 될 클래스 변수는 바로 상수입니다. **`final`** 을 공부할 때 상수를 보긴 했지만, 상수를 더 상수답게 쓰려면 **`static`** 과 함께 쓰는 것이 좋습니다. 상수는 인스턴스에 해당되는 것이 아니며, **여러 복사본 대신 한 값만** 저장해두는 것이 맞기 때문입니다. 상수 이름은 보통 모두 대문자로 쓰고, 단어가 여러 개인 경우 **`_`** 로 구분 짓습니다.

```java
public class CodeitConstants {
    public static final double PI = 3.141592653589793;
    public static final double EULERS_NUMBER = 2.718281828459045;
    public static final String THIS_IS_HOW_TO_NAME_CONSTANT_VARIABLE = "Hello";

    public static void main(String[] args) {
        System.out.println(CodeitConstants.PI + CodeitConstants.EULERS_NUMBER);
    }
}
```

```
5.859874482048838
```

# 1**1. 인스턴스 메소드 vs. 클래스 메소드***

클래스 변수에 이어서 클래스 메소드도 살펴봅시다.

## **클래스 메소드란?**

**클래스 변수**는 인스턴스가 아닌 **클래스에 속한 변수**였습니다. 마찬가지로, **클래스 메소드**는 인스턴스가 아닌 **클래스에 속한 메소드**입니다. 클래스 메소드는 언제 사용할까요? '인스턴스 메소드'는 인스턴스에 속한 것이기 때문에, 반드시 인스턴스를 생성해야 사용할 수 있습니다. 하지만 '클래스 메소드'는 클래스에 속한 것이기 때문에, 인스턴스를 생성하지 않고도 바로 실행할 수 있습니다. 인스턴스를 생성하지 않는 클래스, 어떤 것이 있을까요? 두 가지 예를 살펴봅시다.

## **Math 클래스**

수학 관련 기능을 모아둔 **`Math`** 클래스를 **`import`** 해서 봅시다.

```java
import java.lang.Math;

public class Driver {
    public static void main(String[] args) {
        System.out.println(Math.abs(-10));   // 절댓값
        System.out.println(Math.max(3, 7));  // 두 값 중 최댓값
        System.out.println(Math.random());   // 0.0과 1.0 사이의 랜덤값
    }
}
```

```
10
7
0.40910432549890663
```

이렇게 **`Math.abs()`**, **`Math.max()`** 등을 사용하면, 자바에서 미리 만들어 둔 수학 관련 기능을 활용할 수 있습니다. 하지만 우리는 Math 클래스의 인스턴스를 생성하지는 않습니다. 필요하지 않기 때문이죠. 단지 **`Math`** 클래스의 기능(메소드)만 활용하면 됩니다. 이렇게 인스턴스의 생성 없이 메소드만 모아서 사용하고 싶을 때, 클래스 메소드를 사용할 수 있습니다. **`Math`** 클래스에 있는 **`abs()`**, **`max()`**, **`random()`** 등의 메소드가 바로 '클래스 메소드'입니다.

## **main 메소드**

사실 우리가 가장 먼저 접한 '클래스 메소드'는 바로 **`main`** 메소드입니다.

```java
public static void main(String[] args) {
    ...
}
```

**`main`** 은 자바 프로그램의 시작점이라고 했습니다. 첫 번째로 실행되는 코드이니, 어떤 인스턴스도 생성되어 있지 않겠죠? **`main`** 메소드 역시 인스턴스를 생성하지 않고 실행하는 '클래스 메소드'입니다. 클래스 변수를 정의하기 위해서는 **`static`** 이라는 키워드를 사용했었죠? 클래스 메소드도 동일하게 **`static`** 이라는 키워드로 정의할 수 있습니다. **`main`** 앞에 **`static`** 키워드가 있는 걸 보니, 클래스 메소드가 확실하네요.

## **클래스 변수를 다룰 때**

이 외에도, 앞서 살펴본 '클래스 변수'를 다룰 때 사용할 수 있습니다. 만약 인스턴스와 직접적인 관계가 없는 클래스 변수를 바꾸려면, 아래와 같이 클래스 메소드를 사용할 수도 있겠죠? **`count`** 라는 클래스 변수를 **`increment()`** 라는 클래스 메소드로 바꿔봅시다.

```java
public class Counter {
    static int count;

    public static void increment() {
        count++;
    }

    public static void main(String[] args) {
        System.out.println(Counter.count);

        Counter.increment();
        System.out.println(Counter.count);

        Counter.increment();
        System.out.println(Counter.count);

        Counter.increment();
        System.out.println(Counter.count);
    }
}
```

```
0
1
2
3
```

## **언제 클래스 메소드를 쓰면 되나요?**

이제 인스턴스 메소드와 클래스 메소드의 차이가 이해 되시나요? 언제 클래스 메소드를 써야할지 판단하기 어렵다면, 이 질문을 해보세요. "생성된 인스턴스가 하나도 없더라도 이 메소드를 호출하는 게 말이 되나요?" 정답이 'Yes'라면 클래스 메소드, 즉 **`static`** 메소드를 사용하면 됩니다!

# 12. 단위 변환기

단위 변환기를 만들어봅시다. 우리가 만들 단위 변환기는 인스턴스를 생성하지 않고도 사용할 수 있도록, 클래스 변수와 클래스 메소드로만 이루어져 있습니다. 언제든 간편하게 사용할 수 있는 도구를 만드는 거죠!

## **상수**

이 클래스와 관련 있는 상수(**`static final`** 변수)를 만들어야 합니다.

```
1 파운드 = 0.45359237 킬로그램
1 인치 = 2.54 센티미터
```

위의 두 공식을 이용해서 상수 네 개(**`KILOGRAMS_PER_POUND`**, **`POUNDS_PER_KILOGRAM`**, **`CENTIMETERS_PER_INCH`**, **`INCHES_PER_CENTIMETER`**)를 만들어보세요.

### **예시**

```java
public static final double KILOGRAMS_PER_POUND = 0.45359237;
```

## **클래스 메소드**

앞서 만든 상수들을 활용하여 무게와 길이 단위를 전환하는 메소드를 만들어주세요. 추가로 섭씨에서 화씨로, 또 화씨에서 섭씨로 전환하는 메소드도 만들어주세요. 섭씨를 화씨로 전환하는 수학적 공식은 아래와 같습니다:

```
°F = °C × (9 / 5) + 32
```

그리고 화씨를 섭씨로 전환하는 수학적 공식은 아래와 같습니다:

```
°C = (°F − 32) x (5 / 9)
```

## **보너스: private 생성자**

**`UnitConverter`** 클래스는 인스턴스를 만들지 않고, **`static`** 한 방법으로만 사용하고 싶습니다. 이런 경우, 생성자를 **`private`** 으로 선언하여 인스턴스 생성을 막을 수 있습니다. **`UnitConverter`** 의 생성자를 **`private`** 으로 만들어 외부에서 인스턴스 생성을 못 하게 막아주세요!

```
35 lb -> 15.88 kg
62 kg -> 136.69 lb
12.2 in -> 30.99 cm
3.82 cm -> 1.50 in
48 °F -> 8.89 °C
-9 °C -> 15.80 °F
```

### **참고**

[임페리얼 유닛 (위키피디아)](https://en.wikipedia.org/wiki/Imperial_units)

[섭씨 (위키피디아)](https://ko.wikipedia.org/wiki/%EC%84%AD%EC%94%A8)

### 코드

Main.java

```java
public class Main {
    public static void main(String[] args) {
        System.out.format("35 lb -> %.2f kg\\n", UnitConverter.toKilograms(35));
        System.out.format("62 kg -> %.2f lb\\n", UnitConverter.toPounds(62));
        System.out.format("12.2 in -> %.2f cm\\n", UnitConverter.toCentimeters(12.2));
        System.out.format("3.82 cm -> %.2f in\\n", UnitConverter.toInches(3.82));
        System.out.format("48 °F -> %.2f °C\\n", UnitConverter.toCelsius(48));
        System.out.format("-9 °C -> %.2f °F\\n", UnitConverter.toFahrenheit(-9));
    }
}
```

UnitConverter.java

```java
public class UnitConverter {
    // 필요한 상수 정의

    public static double toPounds(double kilograms) {
        // 메소드 내부를 채워주세요
    }
    public static double toKilograms(double pounds) {
        // 메소드 내부를 채워주세요
    }
    public static double toCentimeters(double inches) {
        // 메소드 내부를 채워주세요
    }
    public static double toInches(double centimeters) {
        // 메소드 내부를 채워주세요
    }
    public static double toFahrenheit(double celsius) {
        // 메소드 내부를 채워주세요
    }
    public static double toCelsius(double fahrenheit) {
        // 메소드 내부를 채워주세요
    }
}
```

## 해답

UnitConverter.java

```java
public class UnitConverter {
    static final double KILOGRAMS_PER_POUND = 0.45359237;
    static final double POUNDS_PER_KILOGRAM = 1/KILOGRAMS_PER_POUND;
    static final double CENTIMETERS_PER_INCH = 2.54;
    static final double INCHES_PER_CENTIMETER = 1/CENTIMETERS_PER_INCH;

    private UnitConverter() {
        // 인스턴스 생성불가
    }

    public static double toPounds(double kilograms) {
        return kilograms * POUNDS_PER_KILOGRAM;
    }
    public static double toKilograms(double pounds) {
        return pounds * KILOGRAMS_PER_POUND;
    }
    public static double toCentimeters(double inches) {
        return inches * CENTIMETERS_PER_INCH;
    }
    public static double toInches(double centimeters) {
        return centimeters * INCHES_PER_CENTIMETER;
    }
    public static double toFahrenheit(double celsius) {
        return celsius * 9 / 5 + 32;
    }
    public static double toCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }
}
```